---
title: "알고리즘 II - 알고리즘 분석"
excerpt: "프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략"
date: 2022-04-20 20:00:00 +0900
header:
  overlay_image: /assets/images/unsplash-thomas-t-math.jpg
  overlay_filter: 0.5
  caption: "Photo by [**Thomas T**](https://unsplash.com/@pyssling240) on [**Unsplash**](https://unsplash.com/)"
categories:
  - Algorithm
mathjax: "true"
---
**Notice:** 본 포스트는 『프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략』 책을 공부하며 쓴 글입니다.
{: .notice--info}

# II. 알고리즘 분석

## 04. 알고리즘 시간 복잡도 분석

### 4.1 도입

빠른 알고리즘을 만들기 위해서는 알고리즘의 속도를 예측할 수 있어야한다. 몇 가지 예제를 통해 알아보자.

### 4.2 선형 시간 알고리즘

#### 다이어트 현황 파악: 이동 평균 계산하기

시간에 따라 관찰된 숫자들이 주어질 때 M-이동 평균은 마지막 M개의 관찰 값의 평균으로 정의된다. N개의 측정치가 주어질 때 M-이동 평균을 구하는 코드는 다음과 같다. *j*를 사용하는 반복문은 항상 *M*번 실행되고 *i*를 사용하는 반복문은 *N - M + 1*번 실행되프로 전체 반복문은 $M \times (N - M + 1) = N \cdot M - M^2 + M$번 반복된다. $N=12, M=3$이면 반복 횟수는 30번이다.

```python
def movingAverage1(A: list, M: int):
    N: int = len(A)
    ret = []
    for i in range(M - 1, N):
        partialSum = 0
        for j in range(M):
            partialSum += A[i - j]
        ret.append(partialSum / M)
    return ret
```

만약 *N=1,000,000*, *M=10,000*이라면 약 99억회의 반복이 필요해진다.  
중복된 계산을 없애서 빠른 프로그램을 짤 수 있다.

| 순서 | 1 | 2 | 3 | ... | M - 1 | M | M + 1 |
| 첫 번째 이동 평균에 포함 |**3.5**|**3.5**|**3.6**| ... | **80.2** | **80.1** | <span class="custom-faint">80.3</span> |
| 두 번째 이동 평균에 포함 |<span class="custom-faint">3.5</span>|**3.5**|**3.6**| ... | **80.2** | **80.1** | **80.3** |

위의 표를 보면 첫 번째 이동 평균 계산에 포함되는 값들과 두 번째 이동 평균 계산에 포함되는 값이 거의 겹치는 것을 알 수 있다. 이를 이용해서 M까지 누적합에서 1일째 값을 뺀 후 M+1번째 값을 더하면 2~M+1번째까지의 합을 구할 수 있다. 이 아이디어를 구현한 코드는 다음과 같다.

```python
def movingAverage2(A: list, M: int):
    N: int = len(A)
    ret = []
    partialSum = 0
    for i in range(M - 1):
        partialSum += A[i]
    for i in range(M - 1, N):
        partialSum += A[i]
        ret.append(partialSum / M)
        partialSum -= A[i - M + 1]
    return ret
```

위 코드의 수행 시간은 *N*에 정비례하여 증가하게 되며, 이런 알고리즘을 선형 시간(linear time) 알고리즘이라고 부른다.

### 4.3 선형 이하 알고리즘

#### 이진 탐색

> `binsearch(A[], x)` = 오름차순으로 정렬된 배열 `A[]`와 찾고 싶은 값 `x`가 주어질 때 $A[i - 1] < x \le A[i]$인 $i$를 반환한다. 이 때 $A[-1]=-\inf$, $A[N]=\inf$로 가정한다. 

쉽게 설명하자면 정렬된 배열 A[]에서 x를 삽입할 수 있는 위치 중 가장 앞을 반환한다고 생각하면 쉽다. A[]에 x가 이미 존재하는 경우 이 함수는 첫 번째 x의 위치를 반환하고, 없는 경우 x보다 큰 첫 번째 원소를 반환한다.

### 4.4 지수 시간 알고리즘

#### 다항 시간 알고리즘

변수 $N$과 $N^2$, 그 외 $N$의 거듭제곱들의 선형 결합으로 이루어진 식들을 다항식이라고 부르며, 반복문의 수행 횟수를 입력 크기의 다항식으로 표현할 수 있는 알고리즘들을 다항 시간 알고리즘이라고 부른다.

#### 지수 시간 알고리즘
*N*이 하나 증가할 때마다 걸리는 시간이 배로 증가하는 알고리즘들은 지수 시간에 동작한다고 말한다. <span class="custom-highlight">다항 시간과 지수 시간 사이의 경계는 현재 전산학에서 효율적으로 해결할 수 있는 문제와 효율적으로 해결하는 방법을 아직 찾아내지 못한 문제의 경계 역할을 하고 있다.</span> 

### 4.5 시간 복잡도

시간 복잡도(time complexity)란 가장 널리 사용되는 알고리즘의 수행 시간 기준으로, 알고리즘이 실행되는 동안 수행하는 기본적인 연산의 수를 표현한 것이다. 예를 들어 두 32비트 정수의 사칙 연산, 두 실수형 변수 크기 비교, 변수 대입 같은 것이 기본 연산에 속한다. 이에 반해, 정렬, 문자열이 같은지 확인하는 것과 같은 작업은 반복문을 포함하기 때문에 기본적인 연산이 아니다. 

#### 점근적 시간 표기: O 표기

여기에서 한 발 더 나아가서 주로 Big-O Notation을 사용해 알고리즘의 수행 시간을 표기한다. Big-O Notation은 간단하게 말하면 주어진 함수에서 가장 빨리 증가하는 항만 남기고 나머지는 생략하는 표기법이다. 

- $\frac{1}{64}N^2M + 64NM = O(N^2 M)$
- $N^2M + N \lg M + NM^2 = O(N^2M + NM^2)$

#### 시간 복잡도의 분할 상환 분석

가끔은 문제의 조건에 따라 시간 복잡도를 정확하게 계산하는 것도 가능하다. 대표적인 예가 시간 복잡도의 분할 상환 분석(amortized analysis)을 사용하는 것이다. 예를 들어 만약 N개의 작은 작업에 대해서 각 작업의 소요 시간은 모두 다르지만 전체 작업에 걸리는 시간은 일정할 경우가 존재한다. 

### 4.6 수행 시간 어림짐작하기

#### 주먹구구 법칙

프로그래밍 대회에서 수행 시간을 예측할 때 많은 경우 시간 복잡도와 입력 크기만 알고 있더라도 시간을 대략적으로 예측할 수 있다. 최대 입력의 크기 N이 10000이고 제한 시간이 1초인 문제를 푼다고 가정하자. 시간 복잡도가 $O(N^3)$이라고 하면 이 알고리즘으로 시간 내에 문제를 풀 수 있을까? $O(N^2)$이나 $O(N \lg N)$은 어떨까? 보통은 다음과 같은 법칙을 통해 예측을 한다.

> 입력의 크기를 시간 복잡도에 대입해서 얻은 반복문 수행 횟수에 대해, 1초당 반복문 수행 횟수가 1억($10^8$)을 넘어가면 시간 제한을 초과할 가능성이 있다.

이 법칙에는 예외도 많이 있다. 반복문의 내부가 복잡한 경우 시간 초과가 될 수도 있고, 간단할 경우 예상보다 빠르게 동작할 수도 있다. 또한 캐시 메모리나 컴파일 옵션에 따라서도 바뀔 수 있다. 

- $N=1,000$: 이때 $N^3$은 10억으로 주먹구구 법칙 기준을 넘어서므로 주의하는 것이 좋다.
- $N=10,000$: 이때 $N^3$은 1조로 $O(N^3)$ 알고리즘은 시간안에 돌아갈 가능성이 거의 없다. $O(N^2)$ 알고리즘은 주의해야할 범위에 들어간다.
- $N=100,000$: 이때는 $N^2$도 100억으로 기준의 백 배이다. 따라서 시간 안에 돌아갈 가능성이 높지 않다. 반면 $N \lg N$은 대략 2천만 정도로 수월하게 돌아간다.

### 4.7 계산 복잡도 클래스: P, NP, NP-완비

다양 시간 알고리즘이 존재하는 문제들의 집합을 P 문제라고 부른다. NP 문제란 답이 주어졌을 때 이것이 정답인지 다항 시간 내에 확인할 수 있는 문제를 의미한다. NP 클래스 안에 있는 모든 문제가 어떤 문제 Q로 환원 가능하면 그 문제 Q는 NP-Hard이다. NP-Hard 문제이면서 NP인 문제들을 NP-Complete 문제라고 한다. 

#### P=NP?
NP-Hard 문제 중 하나를 다항 시간에 풀 수 있다면 이 알고리즘을 이용해 NP에 속한 모든 문제를 다항 시간에 풀 수 있다. 이 경우 NP에 속한 문제를 다항 시간에 해결할 수 있으므로 $P=NP$임을 알 수 있다. 그 반대로 NP 문제 중 하나를 골라 P에 포함되어 있지 않음을, 다시 말해 다항 시간에 푸는 방법이 없음을 증명하면 $P \ne NP$ 임을 보일 수 있다. 어려운 문제를 풀 때 그 문제가 NP-Hard나 NP-Complete 임을 깨달았다고 하자. 그러면 그 문제를 푸는 다른 방법을 찾는 것이 합리적일 것이다.


## 05. 알고리즘의 정당성 증명

### 5.1 도입

#### 알고리즘의 정당성 증명

문제가 복잡해지면 알고리즘이 과연 제대로 동작하는지 파악하기 까다로워진다. 여러 테스트를 통해 답을 점검해볼 수는 있지만, 모든 입력에 대해 정확하게 동작한다는 사실을 증명할 수는 없다. 알고리즘의 정확한 증명을 위해서는 각종 수학적 기법이 동원되어야 한다.  
알고리즘의 증명을 공부해야 하는 가장 큰 이유는 많은 경우 <span class="custom-highlight">증명이 알고리즘을 유도하는 데 결정적인 통찰을 담고 있기 때문</span>이다. 또한, 자신이 설계한 알고리즘의 정당성을 쉽게 증명할 수 있다.

### 5.2 수학적 귀납법과 반복문 불변식

100개의 도미노가 순서대로 놓여 있는 광경을 상상해보자. 그리고 우리가 두 가지 사실을 안다고 가정하자.

- 첫 번째 도미노는 직접 손으로 밀어서 쓰러뜨린다.
- 한 도미노가 쓰러지면 다음 도미노 역시 반드시 쓰러진다.

그러면 마지막 도미노 또한 당연히 쓰러진다는 것을 직관적으로 알 수 있다. 수학적 귀납법<sup>mathematical induction</sup>은 이와 같이 반복적인 구조를 가진 명제들을 증명하는 데 유용하게 사용되는 증명 기법이다. 이는 크게 세 단계로 나누어진다.

- **단계 나누기**: 증명하고 싶은 사실을 여러 단계로 나눈다. 100개의 도미노를 하나씩으로 나눈 것처럼.
- **첫 단계 증명**: 첫 단계에서 증명하고 싶은 내용이 성립함을 보인다. 
- **귀납 증명**: 한 단계에서 증명하고 싶은 내용이 성립한다면, 다음 단계에서도 성립함을 보인다. 

실제 예시로 사다리 게임을 생각해보자. 사다리 게임을 하다 보면 맨 위 선택지와 맨 아래 결과가 항상 1:1로 대응 되는 것이 신기할 때가 있다. 귀납법을 이용해 이를 증명해보자.

- **단계 나누기**: N개의 세로줄에서 시작해서 원하는 사다리가 될 때까지 하나씩 가로줄을 그어 간다고 하자. 이때 가로줄 하나 긋는 것을 한 단계라고 하자.
- **첫 단계 증명**: 텅 빈 N개의 세로줄 상태에서는 항상 맨 위 선택지와 맨 아래 선택지가 1:1 대응이 된다.
- **귀납 증명**: 가로줄을 그어서 두 개의 세로줄을 연결했다고 하자. 이때 두 세로줄의 결과는 서로 뒤바뀐다. 두 줄의 결과가 뒤바뀔 경우 1:1 대응은 변하지 않으므로 다음 단계에서도 1:1 속성이 유지된다.


#### 반복문 불변식

귀납법은 알고리즘의 정당성을 증명할 때 가장 유용하게 사용되는 기법이다. 귀납법을 이용해 알고리즘의 정당성을 증명할 때는 반복문 불변식<sup>loop invariant</sup>라는 개념이 유용하게 쓰인다. 
불변식을 이용하면 반복문의 정당성을 증명할 수 있다.
1. 반복문 진입시에 불변식이 성립함을 보인다.
2. 반복문 내용이 불변식을 깨뜨리지 않음을 보인다. 즉, 반복문 내용이 시작할 때 불변식이 성립했다면 내용이 끝날 때도 불변식이 항상 성립함을 보인다.
3. 반복문 종료시에 불변식이 성립하면 항상 우리가 정답을 구했음을 보인다.

1번과 2번을 증명했다면 수학적 귀납법을 이용해 항상 이 불변식이 성립함을 보일 수 있다.

#### 단정문을 이용해 반복문 불변식 강제하기

assert를 통해 반복문이 깨졌을 때 디버그가 용이하다.

### 5.3 귀류법

원하는 바와 반대되는 상황을 가정하고 논리를 전개해서 결론이 잘못됐음을 찾아내는 증명 기법을 귀류법이라고 한다. 대개 귀류법은 어떤 선택이 항상 최선임을 증명하고자 할 때 많이 이용된다.

### 5.4 다른 기술들

#### 비둘기집의 원리

10마리의 비둘기가 9개의 비둘기집에 모두 들어갔다면, 2마리 이상이 들어간 비둘기집이 반드시 하나는 있게 마련이다. 

#### 구성적 증명

하늘을 나는 교통 수단을 만들 수 있다는 주장을 증명하기 위해 실제로 비행기를 만들어서 보여주는 것.

#### 안정적 결혼 문제

n명의 남성과 여성이 단체 미팅에서 만나는 상황을 가정해보자. 모든 사람들이 자신이 원하는 상대방의 우선순위를 맘 속에 정했고, 시간이 되어 남자 1호와 여자 1호가, 남자 2호와 여자 2호가 각각 짝이 되었다. 그런데 남자 1호와 여자 2호는 자신들의 짝(여자 1호, 남자 2호)보다 서로를 더 선호 한다는 사실을 알게 되었다. 이런 일이 일어나지 않도록 짝을 지어줄 수 있는 방법이 항상 있을까?
안정적 결혼 문제라고 부르는 이 문제는 구성적 증명으로 해결되는 대표적 문제이다. 문제를 해결할 수 있는 다음과 같은 알고리즘을 제시하여 답이 증명함을 보였다.

1. 처음에는 여성들이 모두 자신이 선호하는 남성의 앞에 가서 프로포즈를 한다. 남성은 그중 제일 마음에 드는 여성을 고르면 나머지는 퇴짜를 맞고 제자리로 돌아간다.
2. 퇴짜를 맞은 여성들은 (상대에게 짝이 있는지 없는지 관계 없이) 다음으로 마음에 드는 남성에게 다가가 프로포즈를 한다. 만약 남성에게 현재 자기 짝보다 더 맘에 드는 여성이 다가왔다면, 지금의 파트너에게 퇴짜를 놓고 새 여성에게 넘어간다. 
3. 더 프로포즈할 여성이 없을 때까지 2번 항목을 반복한다.

종료 증명: 각 여성은 퇴짜 맞을 때마다 지금까지 프로포즈했던 남성들보다 우선순위가 낮은 남성에게 프로포즈한다. 따라서 각 여성이 최대 n명의 남성들에게 프로포즈한 이후엔 더 이상 프로포즈할 남성이 없으므로 이 과정은 언젠가 종료된다.  
모든 사람들이 짝을 찾는지 증명: 프로포즈를 받은 남성은 그중 한 사람을 반드시 선택하고, 더 우선순위가 높은 여성이 프로포즈해야만 짝을 바꾸므로 한 번이라도 프로포즈를 받은 남성은 항상 짝이 있기 마련이다. 귀류법을 적용하여 남녀 한 사람씩 짝을 찾지 못하고 남았다고 가정하자. 그런데 여성은 우선순위 순서대로 모두에게 한 번씩 프로포즈하기 때문에, 이 남성에게도 한 번은 프로포즈했을 것이다. 그 때 이 남성은 프로포즈를 받아들였어야 했을 것이고, 따라서 짝을 찾지 못하는 사람은 있을 수 없을 것이다.  
짝들의 안정성: 역시 귀류법으로 증명한다. 이 과정을 결과로 짝을 지었는데 짝이 아닌 두 남녀가 서로 자신의 짝보다 상대방을 더 선호한다고 가정하자. 그렇다면 여성은 지금 자신의 짝 이전에 그 남성에게 먼저 프로포즈했어야 한다. 그런데도 이 남성이 이 여성과 짝지어지지 않았다는 말은 더 맘에 드는 여성에게 프로포즈를 받아서 수락한 경우 외엔 있을 수 없다. 따라서 우리가 가정한 상황은 존재할 수 없다.