---
title: "Docker 기초"
excerpt: "Docker 기초"
date: 2023-03-17 17:00:00 +0900
header:
  image: /assets/images/unsplash-emile-perron.jpg
  caption: "Photo by [**Emile Perron**](https://unsplash.com/@emilep) on [**Unsplash**](https://unsplash.com/)"
categories:
  - Docker
---

## 01. Docker 기초

- 컨테이너 기술의 발전
- 파트 구성
- 챕터 구성

### 컨테이너 기술의 발전

기업들이 "어떻게 서비스를 효율적으로 운영할 것인가?"에 대한 고민이 계속 있어왔다.  
전통적인 Application 배포는 OS 위에서 Library, Framework를 설치 후 Application 수행하는 방식이었다.  
하지만 하나의 서버에서 여러 Application을 수행할 경우 각 App별로 서로 다른 Library를 필요로 할 수 있고, 동일한 Library의 다른 버전이 필요할 수도 있다. 이런 경우 충돌의 위험이 존재하며, 혹은 추가적으로 의존 라이브러리를 App과 같이 배포해주어야 한다.  
하나의 서버 안에서 여러가지 App을 원활히 동작할 수 있게하기위해 "가상화"를 도입되었다. Hypervisor 위에서 가상머신을 여러 개 띄워두고 동작할 수 있으며, 각각의 가상머신을 Guest OS라 부른다. 각각의 Guest OS는 하나의 컴퓨터처럼 취급이 되며 다른 가상머신과 격리된 환경이 된다. 1개의 VM 안에 1개의 App에 필요한 라이브러리들을 설치 후 수행할 수 있다. 이 가상머신의 문제점은 가상머신을 띄우기 위한 자원 오버헤드가 크며 성능의 효율성이 떨어진다는 점이다.  
이런 문제를 해결하기 위해 나온 기술이 **컨테이너** 기술이다. docker는 컨테이너 엔진 중 하나이다. 도커 위에 올라가는 각각의 Box는 Container라고 부르고 하나의 프로세스가 된다. 호스트 프로세스의 커널을 공용으로 사용하며 "격리된 것처럼" 동작하게 된다. 성능 효율성이 가상머신에 비해 효율적이다. 파일시스템도 격리되어 있어 의존성 충돌도 없다.  
쿠버네티스는 Container Orchestration System 중 하나이다. 도커는 하나의 서버 위에서 동작하는 것이고, 클러스터 환경에서 컨테이너를 관리하는 기술/소프트웨어이다.  

### docker 및 docker-compose 설치(Ubuntu)

Docker의 공식 document page를 참고하자.

## 02. Docker를 이용한 컨테이너 관리

### 도커 이미지와 컨테이너

#### 도커 구성요소

- 클라이언트에서 docker 명령어 사용
- DOCKER_HOST(도커 엔진이 띄워져 있는 서버) (현재 실습에서는 서버/클라이언트를 같은 컴퓨터에 설치함)
  - HOST에서 도커 이미지와 컨테이너를 관리한다.
  - 도커 이미지는 직접 빌드할 수도 있고, 이미지 저장소에서 가져올 수도 있다.
  - 도커 이미지를 실행하면 컨테이너가 된다.

![docker_components.png]({{site.baseurl}}/assets/images/docker_components.png)

#### 도커 이미지와 컨테이너

- 이미지(Image): 컨테이너를 생성할 때 필요한 요소, 컨테이너 목적에 맞는 바이너리와 의존성이 설치되어 있음.
- 컨테이너(Container): 이미지를 통해 만들어진 프로세스이다. 이미지는 읽기 전용이며 변경사항은 컨테이너 계층에 저장됨.

이미지와 컨테이너는 1:N 관계이다.  

도커 이미지를 만들 때 사용하는 파일이 dockerfile이다. 도커 이미지를 `docker run`을 통해 실행하면 docker container가 된다.  
컴퓨터 프로그램에 비유하자면 도커 이미지는 프로그램, 컨테이너는 프로세스에 해당한다.  

![docker_file_image_container.png]({{site.baseurl}}/assets/images/docker_file_image_container.png)

#### 도커 이미지 이름 구성

`저장소 이름(Repo)/이미지 이름(Image)/이미지 태그(Tag)`  

- 저장소 이름 생략 시 기본 저장소인 도커 허브 사용
- 태그 생략하면 최신 리비전 사용

#### 도커 이미지 저장소

- 도커 이미지를 관리하고 공유하기 위한 서버 어플리케이션

### 도커 컨테이너 다루기: 도커 컨테이너 라이프 사이클

#### 도커 컨테이너 라이프 사이클

![docker_container_lifecycle.png]({{site.baseurl}}/assets/images/docker_container_lifecycle.png)

#### 컨테이너 시작

- **컨테이너 생성 및 시작**: `docker run [image]`
  - 이미지가 없다면 이미지를 받고, 컨테이너 생성 및 시작
- 컨테이너 생성: `docker create [image]`
- 컨테이너 시작: `docker start [container]`
- 컨테이너 목록(실행 중): `docker ps`
- 컨테이너 목록(모두): `docker ps -a`

#### 컨테이너 시작 실습

```bash
docker run nginx
# nginx 실행, [Ctrl+C]로 종료

docker ps
# 실행 중인 컨테이너 없음

docker ps -a
# Exit되었음을 확인

docker create nginx
# 컨테이너 생성, 컨테이너 고유 ID가 출력됨

docker ps -a
# Created 상태 확인

docker start gifted_ganguly(NAME)
```

#### 컨테이너 시작 주요 옵션

```bash
docker run \
  -i \        # 호스트의 표준 입력을 컨테이너와 연결(interactive)
  -t \        # TTY 할당, 보통은 shell 실행 시 -i와 함께 사용
  --rm \      # 컨테이너 실행 종료 후 컨테이너 자동 삭제
  -d \        # 백그라운드 모드로 실행(detached)
  --name hell-world   # 자동 지정 이름 대신 원하는 이름 설정
  -p 80:80    # 호스트 - 컨테이너 간 포트 바인딩
  -v /opt/example:/example    # 호스트 - 컨테이너 간 볼륨 바인딩
  fastcampus/hello-world:lastest \    # 실행할 이미지
  my-command  # 컨테이너 내에서 실행할 명령어(없으면 컨테이너의 기본 명령어 수행)
```

#### 컨테이너 시작 옵션 실습

```bash
docker run ubuntu:focal
# 바로 종료돼버림

docker ps -a
# 기본 명령어는 /bin/bash 였으며, 종료되었음을 확인 가능

docker run -i -t ubuntu:focal
# bash 셸과 입출력을 위해 옵션 추가

ls -l /
# 컨테이너의 파일시스템에서 명령어 수행 가능

exit
# bash 종료

docker ps -a
# 컨테이너 종료 확인

docker run -i -t ubuntu:focal
# 다시 수행

[Ctrl + p, q 입력하여 다시 빠져나올 수 있음]

docker ps
# 아직 컨테이너 수행 중임

docker run nginx
# foreground로 nginx 수행됨

[Ctrl + c]로 종료

docker run -d nginx
# detached(background) 상태로 실행

docker ps

docker run -d --name my-nginx nginx
# 컨테이너 이름 부여

docker run -p 80:80 -d nginx
# 포트 바인딩 옵션(서버의 80번 포트 → 컨테이너의 80번 포트)

curl localhost:80
# 출력에서 nginx가 수행 중임을 확인

docker run ubuntu:focal id
# 'id' 명령어 수행

docker run --rm ubuntu:focal id
# --rm 추가

docker ps -a
# rm 옵션 사용한 컨테이너는 출력 X
```

#### 컨테이너 상태 확인

- 실행 중인 컨테이너 상태 확인: `docker ps`
- 전체 컨테이너 상태 확인: `docker ps -a`
- 컨테이너 상세 정보 확인: `docker inspect [container]`

#### 컨테이너 일시중지 및 재개

- 컨테이너 일시중지: `docker pause [container]`
- 컨테이너 재개: `docker unpause [container]`

#### 컨테이너 종료

- 컨테이너 종료(SIGTERM 전달):  `docker stop [container]`
- 컨테이너 강제 종료(SIGKILL 전달): `docker kill [container]`
- 모든 컨테이너 종료(trick): `docker stop $(docker ps -a -q)`

#### 컨테이너 삭제

- 컨테이너 삭제(실행중인 컨테이너는 불가): `docker rm [container]`
- 컨테이너 종료 후 삭제(SIGKILL 전달): `docker rm -f [container]`
- 컨테이너 실행 종료 후 자동 삭제: `docker run --rm ...`
- 중지된 모든 컨테이너 삭제: `docker container prune`

### 도커 컨테이너 다루기: 엔트리포인트와 커맨드

#### 엔트리포인트와 커맨드

- 엔트리포인트(Entrypoint): 컨테이너가 시작될 때 실행할 기본 실행 파일을 설정합니다.
- 커맨드(Command):  `ENTRYPOINT`로 설정된 실행 파일에 대한 기본 매개 변수를 제공합니다. `CMD`를 사용하여 실행 파일에 대한 매개 변수를 전달할 수 있습니다. Dockerfile에 `ENTRYPOINT`가 없는 경우, `CMD`는 컨테이너에서 실행할 명령어로 사용됩니다.

일반적으로, 컨테이너의 주요 실행 파일을 설정할 때 `ENTRYPOINT`를 사용하고, 실행 파일에 대한 기본 매개 변수를 설정할 때 `CMD`를 사용합니다. 이렇게 하면 사용자가 컨테이너를 실행할 때 필요한 경우 매개 변수를 쉽게 변경할 수 있습니다.

```bash
docker run ubuntu:focal

docker inspect [container id]
# Entrypoint는 null, Cmd는 "/bin/bash"임을 확인 가능
# /bin/bash 명령어가 수행된 것

docker run --entrypoint sh ubuntu:focal
# 위와 같은 방식으로 inspect 해보면 entrypoint가 변경된 것을 확인 가능

docker run --entrypoint echo ubuntu:focal hello world
# "Entrypoint": ["echo"]
# "Cmd": ["hello", "world"]
```

### 도커 컨테이너 다루기: 환경변수

- `docker run` 관련 도움말: `docker run --help`
- 환경 변수 관련 옵션인 `--env(-e)`와 `--env-file` 옵션을 확인할 수 있다.

```bash
docker run -i -t -e MY_HOST=ABC.com ubuntu:focal bash
# 환경 변수 MY_HOST 값을 ABC.com으로 설정

echo $MY_HOST
```

아래와 같은 형식으로 `sample.env` 파일 작성 후 `--env-file ./sample.env` 옵션 사용도 가능하다.

```text
MY_HOST=ABC.com
MY_VAR1=123
MY_VAR2=456
```

**참고:** dockerhub의 이미지들을 확인해보면 환경변수를 통한 환경설정이 필요한 경우가 많다.
{: .notice--info}

### 도커 컨테이너 다루기: 명령어 실행

#### docker exec

`docker exec` 명령어는 **실행중인** 컨테이너에 명령어를 실행한다. 예를 들어 nginx 컨테이너가 실행중에 이슈가 생겼을 때, `docker exec`을 이용하여 접근할 수 있다.

```bash
# docker exec [container] [command]

# my-nginx 컨테이너에 bash 셸로 접속하기
docker exec -i -t my-nginx bash

# my-nginx 컨테이너에 환경변수 확인하기
docker exec my-nginx env
```

#### docker exec 실습

```bash
docker run -d --name my-nginx nginx

docker ps

docker exec my-nginx env
# 컨테이너 내 환경변수 출력

docker exec -i -t my-nginx bash
# bash 셸 실행

ls -l
exit
```

### 도커 컨테이너 다루기: 네트워크

#### 도커 네트워크 구조

![docker_network.png]({{site.baseurl}}/assets/images/docker_network.png)

- veth(Virtual Ethernet)
- docker0: 도커 엔진에 의해 기본 생성되는 브릿지 네트워크(veth와 eth 간 다리 역할)

