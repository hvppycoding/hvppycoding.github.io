---
title: "IC Compiler II - 17 Signoff"
excerpt: "Signoff"
date: 2023-08-02 06:00:00 +0900
header:
  overlay_image: /assets/images/unsplash-Umberto.jpg
  overlay_filter: 0.5
  caption: "Photo by [**Umberto**](https://unsplash.com/@umby) on [**Unsplash**](https://unsplash.com/)"
categories:
  - VLSI
---

## IC Compiler II Unified Flow​

![2023-08-02-icc-flow.png]({{site.baseurl}}/assets/images/2023-08-02-icc-flow.png){: .align-center}  

We are now at the end of the full IC Compiler II flow. We began with design setup and physical synthesis, proceeded to clock tree synthesis and optimization, routed the design, and performed postroute optimization. There are still sign-off steps that need to be performed to validate the results from the tool and prepare the chip for manufacturing.  
이제 전체 IC Compiler II 플로우의 끝에 도달했습니다. 디자인 설정과 물리적 합성으로 시작하여 클록 트리 합성 및 최적화를 진행하고, 디자인을 라우팅하고 포스트라우트 최적화를 수행했습니다. 하지만 아직 툴에서 나온 결과를 검증하고 칩을 제조하기 위한 최종 승인 절차가 남아 있습니다.  
{: .notice--warning}  

## Signoff / DFM

- After route_opt has completed, there are several tasks that are required, and some that might be required
- Required:
  - Sign-off Extraction and STA, with possible ECO
    - Use ECO Fusion for faster timing signoff
  - Sign-off DRC
  - Filler cell insertion (fill gaps between standard cells)
  - Metal Filling (fill metal layers for CMP)
- Possibly required:
  - Functional ECO (pre- or post-freeze-silicon)

Signoff includes several required steps. Sign-off quality extraction and static timing analysis need to be performed, to accurately ensure that setup and hold timing goals are met. Based on this sign-off extraction and timing, engineering change orders (also called ECOs) may need to be performed to fix remaining violations. We will later discuss the ECO Fusion flow that can provide faster timing signoff than traditional flows. We also need to do sign-off quality DRC checking to ensure that all routing rules are met. Filler cell insertion and metal fill is also performed at this part of the flow. Functional ECOs may also be required, if there are later functional changes provided by the front-end designer.  
서명에는 여러 단계가 필요합니다. 서명 품질 추출과 정적 타이밍 분석을 수행하여 설정과 홀드 타이밍 목표가 정확히 충족되도록 확인합니다. 이 서명 추출과 타이밍에 따라, 남은 위반 사항을 해결하기 위해 ECO(Engineering Change Orders 또는 공학 변경 지시서)를 수행해야 할 수도 있습니다. 나중에는 기존 플로우보다 더 빠른 타이밍 서명을 제공할 수 있는 ECO Fusion 플로우에 대해 논의할 예정입니다. 또한 서명 품질의 DRC(Diagnostic Rule Check) 검사를 수행하여 모든 라우팅 규칙이 준수되도록 보장해야 합니다. 채우기 셀 삽입과 메탈 필링도 이 단계에서 수행됩니다. 전프론트 엔드 디자이너에 의해 후에 기능적 변경이 제공되는 경우 기능적 ECO도 필요할 수 있습니다. 이러한 단계들을 통해 디자인이 원하는 명세와 제약 조건을 정확히 충족시키고, 제조에 준비될 수 있도록 합니다. ECO Fusion 플로우에 대한 자세한 내용은 나중에 다룰 예정입니다.  
{: .notice--warning}  

## Signoff / DFM Tasks

![2023-08-02-signoff-dfm-tasks.png]({{site.baseurl}}/assets/images/2023-08-02-signoff-dfm-tasks.png){: .align-center}  

Here is a flow chart of the necessary steps to perform during sign-off. We start by using PrimeTime and StarRC to do sign-off quality extraction and static timing analysis, which may require timing ECOs if timing violations are exposed. Those ECOs can be performed manually or with the easy-to-use ECO Fusion flow. After timing is clean, filler cells can be inserted, since no more changes will be made to the standard cell placement or sizing. Then we use IC Validator with the signoff runset from the foundry to check and fix physical DRCs. When DRCs are fixed, metal filling can be performed. Functional ECOs may interrupt this process at any time as changes come from the front-end design team. In some cases, these functional ECOs can be performed directly. Otherwise you may need to rewind to an earlier step in this flow to make those ECO changes.  
다음은 서명(sign-off) 중에 수행해야 할 필요한 단계에 대한 플로우 차트입니다. 먼저 PrimeTime과 StarRC를 사용하여 서명 품질의 추출과 정적 타이밍 분석을 수행합니다. 이 과정에서 타이밍 위반이 발견되면 타이밍 ECO를 수행해야 할 수도 있습니다. 이러한 ECO는 수동으로 수행하거나 사용하기 쉬운 ECO Fusion 플로우를 사용하여 수행할 수 있습니다. 타이밍이 정상적으로 해결되면, 표준 셀 배치나 크기 조정에 더 이상 변경사항이 없기 때문에 채우기 셀을 삽입할 수 있습니다. 그런 다음, 제조 공정에서 제공하는 서명 실행(runset)을 사용하여 IC Validator를 사용하여 물리적 DRC(Design Rule Check)를 확인하고 수정합니다. DRC가 수정되면 메탈 필링을 수행할 수 있습니다. 기능적 ECO가 발생하는 경우에는 프론트엔드 디자인 팀에서 변경사항이 제공될 수 있으므로 이러한 프로세스를 언제든지 중단시킬 수 있습니다. 일부 경우에는 이러한 기능적 ECO를 직접 수행할 수도 있습니다. 그렇지 않은 경우에는 이 플로우의 이전 단계로 되돌아가서 ECO 변경사항을 수행해야 할 수도 있습니다.  
{: .notice--warning}  

## Pre vs. Post Tape-out ECO

![2023-08-02-pre-post-tapeout-eco.png]({{site.baseurl}}/assets/images/2023-08-02-pre-post-tapeout-eco.png){: .align-center}  

The tool supports two ECO flows. The first is the pre tape-out ECO flow. This flow is less constrained. You are still free to modify standard cell placement and sizing, and insert or remove standard cells. Once the standard cells are locked down, we are in the post tape-out, or metal ECO phase. At this point, the silicon is frozen. Any ECO changes to the netlist will be implemented using spare-cells. Only the routing layers can be changed in the post tape-out ECO flow.  
이 도구는 두 가지 ECO 플로우를 지원합니다. 첫 번째는 타이핑 아웃 이전의 ECO 플로우입니다. 이 플로우는 덜 제한적입니다. 여전히 표준 셀 배치와 크기를 수정하고 표준 셀을 삽입하거나 제거할 수 있습니다. 표준 셀이 확정되면, 타이핑 아웃 이후 또는 메탈 ECO 단계에 진입합니다. 이 시점에서는 실리콘 디자인이 동결됩니다. 넷리스트에 대한 ECO 변경사항은 예비 셀을 사용하여 구현됩니다. 타이핑 아웃 이후의 ECO 플로우에서는 라우팅 레이어만 변경할 수 있습니다.  
{: .notice--warning}  

## Unconstrained (Pre Tape-out) ECO Flow

![2023-08-02-pre-tapeout-eco.png]({{site.baseurl}}/assets/images/2023-08-02-pre-tapeout-eco.png){: .align-center}  

This flow chart outlines the unconstrained or pre-tapeout ECO flow. First, logic changes are patched into the netlist with the eco_netlist command. Then, place_eco_cells is called to place any newly added cells. Manual updates to the clock tree or scan chain may be necessary if flip-flops are added or removed. After the logic is added to the netlist and placed, routing is updated using the route_eco command. Finally, route_opt is called to incrementally improve the timing and fix new logical or routing DRCs.  
이 플로우 차트는 제한이 없거나 타이핑 아웃 이전의 ECO 플로우를 보여줍니다. 먼저 로직 변경사항을 eco_netlist 명령을 사용하여 넷리스트에 적용합니다. 그런 다음 place_eco_cells를 호출하여 새로 추가된 셀들을 배치합니다. 만약 플립플롭이 추가되거나 제거되면 클록 트리나 스캔 체인에 수동 업데이트가 필요할 수 있습니다. 로직이 넷리스트에 추가되고 배치된 후에는 route_eco 명령을 사용하여 라우팅을 업데이트합니다. 마지막으로, route_opt를 호출하여 타이밍을 점진적으로 개선하고 새로운 논리적 또는 라우팅 DRC를 수정합니다.  
{: .notice--warning}  

## Pre-Tapeout ECO Or Unconstrained Flow

![2023-08-02-pre-tapeout-eco-flow.png]({{site.baseurl}}/assets/images/2023-08-02-pre-tapeout-eco-flow.png){: .align-center}  

Let's look more closely at the eco_netlist command. It takes as inputs the current design, and an ECO netlist file that includes the required logic changes. It will identify functional differences between the netlist of the block in memory and this ECO netlist, and output a script that performs the necessary netlist edits to update the current block to functionally match the ECO netlist. Power grid objects and connections remain unchanged, even if there are differences between the current block and the ECO netlist. No PG nets will be created, connected, or disconnected from PG ports or pins. If there are PG net connections to non PG ports or pins, as in the case of tied-off signals, these changes will be made by the eco_netlist command.  
eco_netlist 명령을 자세히 살펴보겠습니다. 이 명령은 현재 디자인과 ECO 넷리스트 파일을 입력으로 받습니다. ECO 넷리스트 파일에는 필요한 로직 변경사항이 포함되어 있습니다. 이 명령은 현재 메모리에 있는 블록의 넷리스트와 ECO 넷리스트 간의 기능적 차이를 식별하고, 현재 블록을 ECO 넷리스트와 기능적으로 일치하도록 업데이트하는 스크립트를 출력합니다. 전력 그리드 객체와 연결은 현재 블록과 ECO 넷리스트 사이에 차이가 있더라도 변경되지 않습니다. PG(Power Grid) 넷은 PG 포트 또는 핀에 연결되거나 연결이 해제되지 않습니다. PG 넷이 PG 포트 또는 핀이 아닌 다른 포트 또는 핀에 연결된 경우, 예를 들어 tied-off 신호의 경우, eco_netlist 명령을 통해 이러한 변경사항이 수행됩니다.  
{: .notice--warning}  

## ECO Placement: `place_eco_cells`

![2023-08-02-eco-placement.png]({{site.baseurl}}/assets/images/2023-08-02-eco-placement.png){: .align-center}  

The eco_netlist command will introduce new netlist logic to the block in memory. This logic must now be placed. The place_eco_cells command performs both global placement and legalization of these ECOed cells. There are two legalization methods used by this command. free_site_only legalization will leave all previous existing standard cells undisturbed, and try to find open gaps in which the new cells can be legalized. Sometimes this leads to excessively large displacements of the new logic if no nearby open placement sites can be found. Legalization will not be performed on these cells. The number of rejected cells is reported and a collection is created called epl_legalizer_rejected_cells so you can track them. For the cells in this collection, you can then call place_eco_cells with the allow_move_other_cells legalization mode. This will allow other cells to shift location to accomodate the new cells. By performing free_site_only legalization first, and then allow_move_other_cells legalization on the remaining illegal cells, disturbance to the placement of pre-existing logic is minimized. The minimum_physical_impact legalization mode combines both types into a single-pass legalization. It is used as part of the Physically aware ECO flow with PrimeTime that will be discussed later.  
eco_netlist 명령은 메모리에 있는 블록에 새로운 넷리스트 로직을 도입합니다. 이제 이 로직을 배치해야 합니다. place_eco_cells 명령은 이러한 ECO 셀들의 전역 배치와 합법화를 모두 수행합니다. 이 명령에는 두 가지 합법화 방법이 사용됩니다. 1) free_site_only 합법화: 이 합법화 방법은 이전에 존재하던 표준 셀들을 변경하지 않고, 새로운 셀들을 합법화할 수 있는 빈 공간을 찾으려고 합니다. 가까운 빈 위치가 없으면 새로운 로직의 큰 이동이 발생할 수 있습니다. 이러한 경우에는 합법화가 수행되지 않으며, 거부된 셀의 수가 보고되며 epl_legalizer_rejected_cells라는 컬렉션이 생성됩니다. 이 컬렉션에 있는 셀들에 대해서는 allow_move_other_cells 합법화 모드를 사용하여 place_eco_cells를 호출할 수 있습니다. 이렇게 함으로써 다른 셀들이 새로운 셀들에 맞게 위치를 이동할 수 있습니다. free_site_only 합법화를 먼저 수행하고, 남은 불법 셀들에 대해 allow_move_other_cells 합법화를 수행함으로써, 기존 로직의 배치에 대한 영향을 최소화합니다. 2) minimum_physical_impact 합법화 모드: 이 모드는 두 가지 합법화 방법을 하나의 단일 합법화로 결합합니다. 이는 나중에 다룰 PrimeTime과 함께 사용되는 물리적 ECO 플로우의 일부로 사용됩니다. 위와 같은 방법들을 통해 ECO 셀들의 배치가 더욱 효율적이고 이전 로직에 미치는 영향이 최소화됩니다. 이러한 ECO 플로우는 나중에 다룰 PrimeTime과 함께 사용되는 물리적 ECO 플로우의 일부로 사용됩니다.  
{: .notice--warning}  

## Unconstrained Flow

![2023-08-02-unconstrained-flow.png]({{site.baseurl}}/assets/images/2023-08-02-unconstrained-flow.png){: .align-center}  

Here again is an outline of the unconstrained or pre-tape-out ECO flow. We just discussed the first two steps with `eco_netlist` and `place_eco_cells` in more detail. `eco_netlist` uses the `-write_changes` option to specify the output Tcl file that contains the changes. Use either of the options -by_verilog_file or -by_block to point to the ECO changes that will be compared to the current block to create this file. Next the ECO changes file is sourced, and `connect_pg_net` is called to patch the power routing connections, since `eco_netlist` will not include power-only changes in that file. `place_eco_cells` is then called to place and legalize the new ECO logic. The `-eco_changed_cells` option is required in this flow. It will automatically identify the new ECO logic from `eco_netlist` as the candidates for placement. Assuming no manual clock tree or scan changes are required, the next step is `route_eco` to perform incremental routing to the new cells, as well as any preexisting cells that had to be moved during `place_eco_cells` to legalize the new cells. `route_eco` executes all three phases of routing: global route, track assignment, and detail route. `route_eco` has several options that can help minimize perturbance to existing routing in the design. The `-utilize_dangling_wires` option, when true, increases reuse of existing routing topologies when fixing opens. `-open_net_driven`, when true, will only perform DRC fixing in the regions near any open nets that were reconnected during ECO routing. The `-reroute modified_nets_first_than_others` option will freeze the routing topologies on full connected nets, and reroute new or modified nets using available resources. Then if violations remain, it will also allow reroute of fully connected nets. These options are most applicable for minor ECO changes. For major ECO operations, more extensive changes to existing routing topologies will be needed, and these options may be too restrictive.  
다시 한번 언컨스트레인트 또는 타이핑 아웃 이전의 ECO 플로우 개요를 살펴보겠습니다. 우리는 `eco_netlist`와 `place_eco_cells`에 대해 더 자세히 논의했습니다. `eco_netlist`는 `-write_changes` 옵션을 사용하여 변경 사항이 포함된 출력 Tcl 파일을 지정합니다. 이 파일은 현재 블록과 비교하여 생성되는 ECO 변경 사항을 가리킵니다. 다음으로 ECO 변경 사항 파일을 소스로 사용하고 `connect_pg_net`을 호출하여 전원 라우팅 연결을 패치합니다. 왜냐하면 `eco_netlist`는 전원에만 영향을 주는 변경 사항을 해당 파일에 포함시키지 않기 때문입니다. 그 다음 `place_eco_cells`를 호출하여 새로운 ECO 로직을 배치하고 합법화합니다. 이 플로우에서는 `-eco_changed_cells` 옵션이 필요합니다. 이 옵션은 `eco_netlist`에서 새로운 ECO 로직을 자동으로 식별하여 배치 대상으로 설정합니다. 수동으로 클록 트리나 스캔 변경이 필요하지 않은 경우, 다음 단계는 `route_eco`입니다. 이 단계에서는 새로운 셀들에 대한 증분적 라우팅과 `place_eco_cells`에서 새 셀들을 합법화하기 위해 이동한 기존 셀들에 대한 라우팅을 수행합니다. `route_eco`는 전역 라우팅, 트랙 할당, 상세 라우팅의 세 가지 단계를 모두 수행합니다. `route_eco`에는 기존 라우팅을 최소화하는 데 도움이 되는 여러 옵션이 있습니다. true로 설정한 `-utilize_dangling_wires` 옵션은 오픈을 수정할 때 기존 라우팅 토폴로지의 재사용을 늘립니다. `-open_net_driven` 옵션도 true로 설정하면 ECO 라우팅 중 재연결된 오픈 넷 근처 영역에서만 DRC 수정을 수행합니다. `-reroute modified_nets_first_than_others` 옵션은 완전히 연결된 넷의 라우팅 토폴로지를 고정한 후, 사용 가능한 자원을 이용하여 새로운 또는 수정된 넷을 재라우팅합니다. 그런 다음 위반 사항이 남아있는 경우, 완전히 연결된 넷의 재라우팅도 허용합니다. 이러한 옵션들은 작은 ECO 변경에 가장 적합합니다. 큰 ECO 작업의 경우, 기존 라우팅 토폴로지에 더 많은 변화가 필요할 수 있으며, 이러한 옵션은 너무 제한적일 수 있습니다.  
{: .notice--warning}  

## Freeze Silicon ECO Flow

![2023-08-02-freeze-silicon-eco-flow.png]({{site.baseurl}}/assets/images/2023-08-02-freeze-silicon-eco-flow.png){: .align-center}  

The freeze silicon or post-tape-out ECO flow is used to make ECO modifications to the metal layers only while freezing the silicon layers. It is activated by setting the app option `design.eco_freeze_silicon_mode` to true. In this mode, most tool commands are disabled and only a limited subset of commands that are freeze-silicon aware are allowed. In this mode, cell placement and sizing is already locked down and cannot be modified, and spare cells have already been inserted. The same `eco_netlist` command used in the unconstrained ECO flow is used to make the changes here, with the change file being sourced afterwards. Then perform any manual updates to your clock tree, scan chain, and UPF. `check_freeze_silicon` analyzes the relationship between the new ECO cells and the available spare cells in the floorplan. The ECO cells are then implemented using the spare cells in one of two ways. `place_freeze_silicon` does automatic mapping to spare cells. Alternately, `map_freeze_silicon` take manual input for how ECO cells should be mapped to spare cells. The `connect_freeze_silicon_tie_cells` commands connects any tied off pins in the ECO cells to the closest available tie cells. Finally, the routing is updated with the `route_eco` command.  
얼음 실리콘 또는 타이핑 이후 ECO 플로우는 실리콘 레이어를 얼리면서 메탈 레이어에만 ECO 수정을 수행하는데 사용됩니다. 이를 위해 `design.eco_freeze_silicon_mode` 앱 옵션을 true로 설정합니다. 이 모드에서 대부분의 도구 명령은 비활성화되며, 얼음 실리콘에 대해 인식하는 일부 명령만 허용됩니다. 이 모드에서는 셀 배치와 크기 조정이 이미 잠겨 있고 수정할 수 없으며, 예비 셀이 이미 삽입되어 있습니다. 언컨스트레인트 ECO 플로우에서 사용한 `eco_netlist` 명령은 여기에서 변경사항을 수행하기 위해 동일하게 사용되며, 변경 파일은 이후에 소스로 사용됩니다. 그런 다음 클록 트리, 스캔 체인 및 UPF에 대한 수동 업데이트를 수행합니다. `check_freeze_silicon`은 새로운 ECO 셀들과 평면에 있는 예비 셀들 사이의 관계를 분석합니다. 그런 다음 ECO 셀들은 두 가지 방법 중 하나로 예비 셀들을 사용하여 구현됩니다. `place_freeze_silicon`은 자동 매핑을 수행합니다. 또는 `map_freeze_silicon`은 ECO 셀들이 예비 셀들에 어떻게 매핑되어야 하는지에 대한 수동 입력을 받습니다. `connect_freeze_silicon_tie_cells` 명령은 ECO 셀들의 연결되지 않은 핀을 가장 가까운 사용 가능한 연결된 핀에 연결합니다. 마지막으로 라우팅은 `route_eco` 명령으로 업데이트됩니다.  
{: .notice--warning}  

## Map ECO Cells to Spare Cells

![2023-08-02-map-eco-cells-to-spare-cells.png]({{site.baseurl}}/assets/images/2023-08-02-map-eco-cells-to-spare-cells.png){: .align-center}  

Mapping the newly introduced ECO cells to spare cells is done by either the `place_freeze_silicon` or `map_freeze_silicon` command. `place_freeze_silicon` does a placement based mapping. First, the ECOed cells are coarse placed, then it identifies the closest compatible spare cells in the floorplan to map them to. With `map_freeze_silicon`, manual mapping can be performed using a map file that associates individual ECO cells with spare cell instances. Any existing netlist cells that are resized or removed during this mapping process can be recycled as spare cells for future ECO iterations.  
새롭게 도입된 ECO 셀들을 예비 셀들에 매핑하는 작업은 `place_freeze_silicon` 또는 `map_freeze_silicon` 명령을 통해 수행됩니다. `place_freeze_silicon`은 배치 기반 매핑을 수행합니다. 먼저 ECO된 셀들이 거칠게 배치되고, 그 다음 평면에 가장 가까운 호환되는 예비 셀들을 식별하여 매핑합니다. `map_freeze_silicon`을 사용하면 매뉴얼 매핑이 가능하며, 개별 ECO 셀들을 예비 셀 인스턴스와 연결하는 맵 파일을 사용하여 수동 매핑을 수행할 수 있습니다. 이 매핑 프로세스 중에 크기가 조정되거나 제거된 기존 넷리스트 셀들은 향후 ECO 반복을 위해 예비 셀로 재활용될 수 있습니다.  
{: .notice--warning}  

## Timing ECOs

![2023-08-02-timing-eco.png]({{site.baseurl}}/assets/images/2023-08-02-timing-eco.png){: .align-center}  

Now that we've discussed both the unconstrained and freeze silicon functional ECO flows, let's consider timing ECOs using PrimeTime for static timing analysis and StarRC for extraction.  
언컨스트레인트 및 얼음 실리콘 기능적 ECO 플로우를 모두 살펴보았으니 이제 PrimeTime을 사용한 타이밍 ECO와 StarRC를 사용한 추출에 대해 고려해보겠습니다.  
{: .notice--warning}  

## PrimeTime Signoff-driven Physically Aware ECO Flow

![2023-08-02-pt-signoff-driven-eco-flow.png]({{site.baseurl}}/assets/images/2023-08-02-pt-signoff-driven-eco-flow.png){: .align-center}  

In this flow, you have already pushed your block's timing performance as far as possible using the native timing and extraction technology of the implementation tool. PrimeTime is used to perform a physical aware ECO flow with sign-off quality timing, crosstalk analysis, and extraction. To do this flow, many types of information must be passed from the implementation tool into PrimeTime, including everything shown in the list, from netlist, SDC, and UPF constraints, to the logic dbs, tech info, and physical libraries. Also, RC parasitics from StarRC are required. All of this information needs to be written out and sent to PrimeTime before we can perform the analysis in PrimeTime. If you perform the analysis and there are no violations, then the flow is complete and no timing ECOs are required. You can proceed with routing DRC signoff and metal fill. But more than likely there will be violations and PrimeTime can be used to perform ECO fixes. Technically, PrimeTime does not perform these fixes. It gives ECO fixing guidance, which is sent back for implementation. For example, PrimeTime may decide that a buffer needs to be added on a long critical net with a particular size and location. PrimeTime communications this information in a file, and the implementation tool reads that guidance and performs the netlist ECO, and ECO placement and routing.  
이 플로우에서는 구현 도구의 기본 타이밍과 추출 기술을 사용하여 블록의 타이밍 성능을 최대한 향상시켰습니다. PrimeTime은 사인오프 품질의 타이밍, 크로스토크 분석 및 추출을 수행하기 위해 물리적인 인지 ECO 플로우를 사용합니다. 이 플로우를 수행하려면 구현 도구에서 PrimeTime으로 여러 유형의 정보를 전달해야 합니다. 이 정보에는 넷리스트, SDC, UPF 제약 조건, 논리 데이터베이스, 기술 정보, 물리 라이브러리 등 모든 목록에 표시된 것들이 포함됩니다. 또한 StarRC의 RC 파라메터도 필요합니다. 이 모든 정보는 PrimeTime으로 기록되어 분석을 수행하기 전에 PrimeTime으로 전송되어야 합니다. 분석을 수행하고 위반 사항이 없는 경우 플로우가 완료되고 타이밍 ECO가 필요하지 않습니다. 라우팅 DRC 사인오프와 메탈 필링을 계속 진행할 수 있습니다. 그러나 아마도 위반 사항이 발생할 것이며, PrimeTime은 ECO 수정 지침을 제공하는 데 사용됩니다. 기술적으로 PrimeTime은 이러한 수정을 수행하지 않습니다. 대신, 특정 크기와 위치에 긴 크리티컬 넷에 버퍼를 추가해야 한다고 판단할 수 있습니다. PrimeTime은 이 정보를 파일로 전달하고, 구현 도구는 그 지침을 읽고 넷리스트 ECO 및 ECO 배치 및 라우팅을 수행합니다.  
{: .notice--warning}  

## Manual ECO Flow vs. Automated

- You can perform PT ECO manually. This means you have to manage
  - Scripts for data export/import in and out of PT/StarRC/ICCII
  - ECO in PT
  - Extraction in StarRC
  - ECO implementation in ICCII
- Or you can let ECO Fusion perform everything automatically
  - Blends IC Compiler II, StarRC and PrimeTime in a single, ICCII-native invocation system
  - Accelerates implementation closure

![2023-08-02-eco-fusion.png]({{site.baseurl}}/assets/images/2023-08-02-eco-fusion.png){: .align-center}  

All of this data export and import between tools can be handled manually. You can manually write scripts to dump the data files from IC Compiler II, run the extraction in StarRC, run the PrimeTime ECO flow, and then come back in to perform the ECO changes to the design. But there is a more streamlined approach available called the ECO Fusion flow that does all of these steps automatically. It coordinates all of the data export and import, handoff between tools, and running of StarRC and PrimeTime ECO, all without ever leaving the IC Compiler II shell.  
모든 이러한 데이터의 내보내기 및 가져오기는 수동으로 처리될 수 있습니다. IC Compiler II에서 데이터 파일을 수동으로 덤프하고, StarRC에서 추출을 실행하고, PrimeTime ECO 플로우를 실행하고, 그런 다음 다시 디자인에 ECO 변경사항을 수행하기 위해 수동으로 스크립트를 작성할 수 있습니다. 그러나 ECO Fusion 플로우라는 더 간소화된 접근 방법이 있습니다. 이 플로우는 모든 단계를 자동으로 처리합니다. 데이터의 내보내기와 가져오기, 도구 간의 핸드오프, StarRC 및 PrimeTime ECO의 실행을 모두 IC Compiler II 쉘에서 빠르고 효율적으로 처리합니다.  
{: .notice--warning}  

## ECO Fusion Workflow

![2023-08-02-eco-fusion-flow.png]({{site.baseurl}}/assets/images/2023-08-02-eco-fusion-flow.png){: .align-center}  

This is all enabled by the `eco_opt` command. `eco_opt` first extracts the parasitics using StarRC, and generates the PrimeTime run files. It does the timing analysis in PrimeTime with distributed multi-scenario analysis. It will then run PrimeTime ECO using the optimization flow that you specify. You can target the ECO changes for fixing setup, hold, noise, power, or any combination of these targets. PrimeTime ECO will generate a changelist that is automatically sourced. Then those ECO changes are executed, new cells are placed, and ECO routing is done. All of this is handled by this one command to save you time and energy to more rapidly complete iterations of the timing ECO flow.  
이 모든 것은 `eco_opt` 명령어로 가능해집니다. `eco_opt`는 먼저 StarRC를 사용하여 파라메터를 추출하고, PrimeTime 실행 파일을 생성합니다. 분산 다중 시나리오 분석을 사용하여 PrimeTime에서 타이밍 분석을 수행합니다. 그런 다음 지정한 최적화 플로우를 사용하여 PrimeTime ECO를 실행합니다. 설정, 홀드, 노이즈, 전력을 수정하는 ECO 변경사항을 목표로 할 수 있습니다. PrimeTime ECO는 자동으로 소스화되는 변경 리스트를 생성합니다. 그런 다음 이러한 ECO 변경사항이 실행되고, 새로운 셀이 배치되며, ECO 라우팅이 수행됩니다. 이 모든 것을 한 번의 명령어로 처리하여 타이밍 ECO 플로우의 반복을 더 빠르게 완료하는 데에 시간과 에너지를 절약할 수 있습니다.  
{: .notice--warning}  

## ECO Fusion Full Flow

![2023-08-02-eco-fusion-full-flow.png]({{site.baseurl}}/assets/images/2023-08-02-eco-fusion-full-flow.png){: .align-center}  

This flowchart shows the ECO Fusion flow in more detail. Earlier in the `postroute` optimization module, we covered the `route_opt` flow. Typically, three rounds of `route_opt` are performed. But in the ECO Fusion flow, only two runs of `route_opt` are needed. `route_opt` is run using the PrimeTime delay calculator and native StarRC extraction enabled. Afterwards, `check_route` and `check_legality` are used to ensure that the design is mostly routing DRC clean. The timing ECO flow needs a clean input, so if there are major legalization or routing violations, continue to work on the earlier flow to clean things up before proceeding. Normally metal fill is performed right at the end of the signoff flow, but optionally you can do an early metal fill at this stage so that PrimeTime can take into account the coupling capacitance effects of all the added metal around your signal nets. `set_pt_options` is used to point to the PrimeTime executable. Then `eco_opt` can be run. Once `eco_opt` has patched the ECO changes back into your designs, you can check the optimization results with `check_pt_qor`. You don't use `report_timing` to do this, which uses the native static timing analysis and RC parasitics of IC Compiler II. `check_pt_qor` looks at the timing using PrimeTime and StarRC. If this command reveals remaining violations, you may choose to iterate this flow a few more times to converge on the solution. Once you are satisfied with your timing ECOs, run `check_legality` and `report_eco_physical_changes` to see what it did. Then you can proceed with the standard filler cell and metal fill insertion steps of the signoff flow.  
이 플로우 차트는 ECO Fusion 플로우를 더 자세히 보여줍니다. 이전의 `postroute` 최적화 모듈에서 `route_opt` 플로우를 다루었습니다. 일반적으로 `route_opt`는 세 번의 라운드를 수행하지만, ECO Fusion 플로우에서는 두 번의 `route_opt` 실행만 필요합니다. `route_opt`는 PrimeTime 지연 계산기와 원래의 StarRC 추출을 사용하여 실행됩니다. 그 후 `check_route`와 `check_legality`를 사용하여 디자인이 대부분의 라우팅 DRC를 만족하는지 확인합니다. 타이밍 ECO 플로우는 깔끔한 입력이 필요하므로, 주요한 legalization 또는 라우팅 위반 사항이 있는 경우, 계속해서 이전 플로우에서 정리 작업을 진행한 후 진행하는 것이 좋습니다. 보통 메탈 필은 signoff 플로우의 맨 끝에 수행하지만, 선택적으로 이 단계에서 초기 메탈 필을 수행할 수 있습니다. 이렇게 하면 PrimeTime이 시그널 넷 주위에 추가된 모든 메탈의 커플링 용량 효과를 고려할 수 있습니다. `set_pt_options`를 사용하여 PrimeTime 실행 파일을 지정합니다. 그런 다음 `eco_opt`를 실행할 수 있습니다. `eco_opt`가 ECO 변경사항을 디자인에 반영한 후 `check_pt_qor`를 사용하여 최적화 결과를 확인할 수 있습니다. 여기서는 IC Compiler II의 기본 정적 타이밍 분석과 RC 파라메터를 사용하는 `report_timing`을 사용하지 않습니다. `check_pt_qor`은 PrimeTime과 StarRC를 사용하여 타이밍을 확인합니다. 이 명령어로 남아 있는 위반 사항을 확인할 수 있다면, 해결책에 수렴하기 위해 몇 번의 더 플로우를 반복할 수 있습니다. 타이밍 ECO가 만족스러울 때까지 이러한 플로우를 몇 차례 반복할 수 있습니다. 만족스러운 타이밍 ECO가 완료되면, `check_legality`와 `report_eco_physical_changes`를 실행하여 ECO가 수행한 변경사항을 확인할 수 있습니다. 그런 다음 signoff 플로우의 표준 filler cell과 메탈 필 삽입 단계로 진행할 수 있습니다.  
{: .notice--warning}  

## Example Flow

![2023-08-02-example-flow.png]({{site.baseurl}}/assets/images/2023-08-02-example-flow.png){: .align-center}  

Here is a sample flow script for how `eco_opt` is setup to invoke PrimeTime and StarRC. PrimeTime uses the liberty DB files, and not the CLIBs. So the `search_path` variable is set to point to the location of those DB files. `set_host_options` is used to configure how the PrimeTime and StarRC jobs are dispatched to your compute farm. Because you are going to use distributed multi-scenario analysis or DMSA in PrimeTime, you might want to take advantage of multiple hosts and cores in your compute farm. With the `set_pt_options` command , you point to the PrimeTime executable location. `set_starrc_options` uses the same configuration file for StarRC discussed in a previous module. That configuration file includes the path to StarRC. See the notes for details. That's all the setup required before running the `eco_opt` command. The `-types` option specifies that you want to fix setup and hold violations. Specifying the `-pba_mode` option runs path-based analysis in Primetime for less pessimism compared to graph-based analysis. `-physical_mode open_site` specifies that ECO cells should only be added where there are open placement sites. Afterwards, the timing from the ECO changes is checked with `check_pt_qor`.  
다음은 `eco_opt`를 설정하여 PrimeTime과 StarRC를 호출하는 예제 플로우 스크립트입니다. PrimeTime은 CLIB 대신 liberty DB 파일을 사용하므로, `search_path` 변수를 설정하여 해당 DB 파일의 위치를 지정합니다. `set_host_options`를 사용하여 PrimeTime과 StarRC 작업이 컴퓨팅 팜에 어떻게 배치되는지 구성합니다. 분산 다중 시나리오 분석 또는 DMSA를 PrimeTime에서 사용할 것이므로, 컴퓨팅 팜의 여러 호스트와 코어를 활용하고 싶을 수 있습니다. `set_pt_options` 명령을 사용하여 PrimeTime 실행 파일 위치를 지정합니다. `set_starrc_options`는 이전 모듈에서 설명한 대로 StarRC의 구성 파일을 사용합니다. 이 구성 파일에는 StarRC의 경로가 포함되어 있습니다. 자세한 내용은 노트를 참조하십시오. `eco_opt` 명령을 실행하기 전에 필요한 모든 설정이 완료되었습니다. `-types` 옵션은 setup과 hold 위반을 수정하려는 것을 지정합니다. `-pba_mode` 옵션을 지정하여 Primetime에서 경로 기반 분석을 실행하면 그래프 기반 분석보다 비관적이지 않습니다. `-physical_mode open_site`는 ECO 셀이 개방된 배치 사이트만 추가되도록 지정합니다. 그런 다음, ECO 변경사항의 타이밍을 `check_pt_qor`로 확인합니다.  
{: .notice--warning}  

## Notes on ECO Fusion

- In order to analyze PrimeTime’s timing results from within ICCII, always use `check_pt_qor`
  - Accesses PrimeTime to generate reports
  - `check_pt_qor -pba_mode path`
  - `check_pt_qor -max_paths 5 -to regB`
- Parasitics are written out by Fusion Extraction, stored on disk and used by PrimeTime; tool will error out if starrc config is not set properly
- Do not use ICCII's `update_timing/report_qor` — this will trigger ICCII extraction and STA

To analyze PrimeTime's ECO changes, remember to use `check_pt_qor` rather than `report_timing` or `report_qor`. This will use PrimeTime to generate the reports. It should be called with the same PBA mode used on the `eco_opt` command. StarRC parasitics are written by StarRC and they will be stored on disk and used by PrimeTime, so they are not loaded into IC Compiler II.  
PrimeTime의 ECO 변경사항을 분석할 때에는 `report_timing`이나 `report_qor` 대신에 `check_pt_qor`를 사용해야 합니다. 이는 PrimeTime을 사용하여 보고서를 생성합니다. `check_pt_qor`는 `eco_opt` 명령에서 사용한 PBA 모드와 동일하게 호출되어야 합니다. StarRC 파라미터는 StarRC에 의해 작성되며 디스크에 저장되어 PrimeTime에서 사용되므로 IC Compiler II에 로드되지 않습니다.  
{: .notice--warning}  

## Filler Cell Insertion

![2023-08-02-filler-cell-insertion.png]({{site.baseurl}}/assets/images/2023-08-02-filler-cell-insertion.png){: .align-center}  

We recommend inserting filler cells with metal first, and then later inserting filler cells without metal. Filler cells with DRC violations are removed. To boost the insertion rate, you may have to iterate when inserting filler cells with metal, going from larger to smaller filler cells. Non-metal filler cells need to be connected to PG just like any cells because they do have power and ground rails.  
우리는 filler cell을 먼저 metal과 함께 삽입한 다음, 나중에 metal 없이 filler cell을 삽입하는 것을 권장합니다. DRC 위반을 가진 filler cell은 제거됩니다. filler cell을 metal과 함께 삽입할 때 insertion rate을 높이기 위해, 큰 filler cell부터 작은 filler cell로 반복해서 삽입해야 할 수도 있습니다. Metal이 없는 filler cell은 전력과 접지 레일을 가지고 있기 때문에, 다른 셀들처럼 전력/접지와 연결되어야 합니다.  
{: .notice--warning}  

## Standard Cell Fillers and Metal Filling

![2023-08-02-standard-cell-fillers.png]({{site.baseurl}}/assets/images/2023-08-02-standard-cell-fillers.png){: .align-center}  

If you have remaining timing/DRC violations after filler cell insertion and metal fill, you need to remove all filler cells before running `route_opt` again. After cleaning up timing or DRC violations, you can re-do filler insertion and metal fill. If there aren't a lot of routing changes, metal fill can be run incrementally.  
filler cell 삽입과 metal fill을 수행한 후에도 남아 있는 timing/DRC 위반 사항이 있다면, `route_opt`를 다시 실행하기 전에 모든 filler cell을 제거해야 합니다. timing이나 DRC 위반 사항을 정리한 후에는 filler 삽입과 metal fill을 다시 수행할 수 있습니다. 라우팅 변경 사항이 많지 않다면, metal fill을 점진적으로 실행할 수도 있습니다.  
{: .notice--warning}  

## Example Script

![2023-08-02-filler-cell-examples.png]({{site.baseurl}}/assets/images/2023-08-02-filler-cell-examples.png){: .align-center}  

Here is a sample script for filler cell insertion. First the filler cells with metal are specified. The `create_stdcell_fillers` command does the actual filler cell insertion. It is called with the option `-rules post_route_auto_delete`. This allows both `route_opt` and `eco_opt` to automatically remove filler cells so they don't have to be manually removed before calling those commands again. First metal filler cells are inserted, and violators are removed. Then non-metal fillter cells are inserted. Every time filler cells are inserted, `connect_pg_net` is called afterwards to do the PG hookups. If you manually remove filler cells, you can wrap the `remove_cells` command with the `eval_with_undo -disable` wrapper command. This disables the command undo feature, which provides a runtime benefit when removing a large number of cells from the database like `remove_cells` is doing here.  
아래는 filler cell 삽입을 위한 샘플 스크립트입니다. 먼저 metal filler cell이 지정됩니다. `create_stdcell_fillers` 명령을 사용하여 실제로 filler cell을 삽입합니다. 이 명령은 `-rules post_route_auto_delete` 옵션과 함께 호출됩니다. 이렇게 하면 `route_opt`와 `eco_opt`가 filler cell을 자동으로 제거하도록 하여 이러한 명령을 다시 호출하기 전에 수동으로 제거할 필요가 없습니다. 먼저 metal filler cell이 삽입되고 위반 사항이 제거됩니다. 그런 다음 non-metal filler cell이 삽입됩니다. filler cell을 삽입할 때마다 `connect_pg_net`이 호출되어 PG 연결이 수행됩니다. filler cell을 수동으로 제거하려면 `remove_cells` 명령을 `eval_with_undo -disable` 래퍼 명령으로 래핑할 수 있습니다. 이렇게 하면 명령 취소 기능이 비활성화되어 `remove_cells`가 여기에서 수행하는 대량의 셀을 데이터베이스에서 제거하는데 런타임 이점을 제공합니다.  
{: .notice--warning}  

## In-Design Signoff DRC Checking and Fixing

![2023-08-02-drc-checking-and-fixing.png]({{site.baseurl}}/assets/images/2023-08-02-drc-checking-and-fixing.png){: .align-center}  

Much like the ECO Fusion flow discussed earlier, where PrimeTime and StarRC are called without ever leaving the implementation tool shell, IC Validator can also be run directly, and the results can be evaluated in the GUI error browser. This is called the In-Design Signoff DRC flow. The benefit of using IC Validator inside the tool is getting signoff quality results of the foundry DRC signoff runset, without going through the hassle of streaming out the GDS and re-importing the DRC results. We can view the signoff DRC errors and fix the them directly. The routing engine takes guidance from IC Validator to do this fixing natively. The GDS stream out only needs to be done once after all IC Validator DRC errors are fixed.  
IC Validator를 사용하여 In-Design Signoff DRC flow를 진행하는 것은 ECO Fusion flow에서의 PrimeTime과 StarRC를 직접 호출하는 것과 유사합니다. 구현 도구 쉘을 벗어나지 않고 IC Validator를 직접 실행하고 결과를 GUI 에러 브라우저에서 평가할 수 있습니다. 이를 통해 GDS를 스트리밍하고 DRC 결과를 다시 가져오는 귀찮음 없이 foundry DRC signoff runset의 signoff 품질 결과를 얻을 수 있습니다. 우리는 signoff DRC 오류를 확인하고 직접 수정할 수 있습니다. 라우팅 엔진은 IC Validator의 가이드를 받아 이러한 수정을 자체적으로 수행합니다. IC Validator DRC 오류를 모두 수정한 후에는 GDS 스트리밍이 한 번만 수행되면 됩니다.  
{: .notice--warning}  

## Signoff DRC using IC Validator

![2023-08-02-signoff-drc-using-icv.png]({{site.baseurl}}/assets/images/2023-08-02-signoff-drc-using-icv.png){: .align-center}  

To perform signoff DRC checking, first point to the DRC runset using the `signoff.check_drc.runset` app option. The `signoff_check_drc` command actually performs the IC Validator DRC checking. By default, all routing and via layers are checked, but you can use the `-select_layers` option to specify a subset of those layers. Sign-off DRC fixing is done using the `signoff_fix_drc` command. It invokes the routing engine to fix the DRC violations identified by the `signoff_check_drc` command. In the end, it runs the IC Validator signoff DRC checking again. This command needs to know where the DRC error database from IC Validator is located. This is specified with the `signoff.fix_drc.init_drc_error_db` app option. When IC Validator runs, it opens the current block from disk. So be sure to save the block before invoking these commands.  
In the In-Design Signoff DRC flow, 우선 `signoff.check_drc.runset` app 옵션을 사용하여 DRC runset을 가리킵니다. 그런 다음 `signoff_check_drc` 명령을 사용하여 IC Validator DRC 검사를 수행합니다. 기본적으로 모든 라우팅 및 비아 레이어가 확인되지만 `-select_layers` 옵션을 사용하여 해당 레이어의 하위 집합을 지정할 수 있습니다. Sign-off DRC 수정은 `signoff_fix_drc` 명령을 사용하여 수행됩니다. 이 명령은 라우팅 엔진을 호출하여 `signoff_check_drc` 명령에서 식별한 DRC 위반을 수정합니다. 마지막으로 IC Validator signoff DRC 검사를 다시 실행합니다. 이 명령은 IC Validator의 DRC 오류 데이터베이스가 위치한 곳을 알아야 합니다. 이는 `signoff.fix_drc.init_drc_error_db` app 옵션으로 지정합니다. IC Validator가 실행되면 현재 블록이 디스크에서 열리므로 이러한 명령을 실행하기 전에 블록을 저장하는 것이 중요합니다.  
{: .notice--warning}  

## ICV Usage Examples

![2023-08-02-icv-usage-examples.png]({{site.baseurl}}/assets/images/2023-08-02-icv-usage-examples.png){: .align-center}  

The first example on this slide shows `signoff_check_drc` being called to run ICV DRC signoff checking. The second one only checks the specified DRC rules. To check certain types of DRCs like double-patterning rules, the CLIB frame views are insufficient. You can use one of two approaches. The first is to specify the `signoff.check_drc.read_design_views` app option to read the full design views of the library cells. Alternatively, use `signoff.physical.merge_stream_files` to merge GDSII and/or OASIS stream data with the existing CLIBs without having to create a new "full" CLIB. The stream files are provided by the vendor. Use `signoff.physical.layer_map_file` to give a layer mapping file for the `signoff_check_drc` or `signoff_create_metal_fill` command. This file maps the layers in the CLIBs to the GDSII runset stream layers. The format of the file is the same as the layer map file used by `read_gds` and `write_gds` commands.  
이 슬라이드의 첫 번째 예제에서는 `signoff_check_drc`를 호출하여 ICV DRC signoff 검사를 실행하는 것을 보여줍니다. 두 번째 예제에서는 지정된 DRC 규칙만을 확인합니다. 이중 패터닝 규칙과 같은 특정 유형의 DRC를 확인하려면 CLIB 프레임 뷰만으로는 부족합니다. 두 가지 접근 방법을 사용할 수 있습니다. 첫 번째 접근 방법은 `signoff.check_drc.read_design_views` app 옵션을 지정하여 라이브러리 셀의 전체 디자인 뷰를 읽는 것입니다. 또는 `signoff.physical.merge_stream_files`를 사용하여 새로운 "full" CLIB을 생성하지 않고 기존의 CLIB에 GDSII 및/또는 OASIS 스트림 데이터를 병합할 수 있습니다. 스트림 파일은 공급업체에서 제공합니다. `signoff.physical.layer_map_file`을 사용하여 `signoff_check_drc` 또는 `signoff_create_metal_fill` 명령에 대한 레이어 매핑 파일을 제공합니다. 이 파일은 CLIB의 레이어를 GDSII runset 스트림 레이어에 매핑합니다. 파일 형식은 `read_gds`와 `write_gds` 명령에서 사용되는 레이어 맵 파일과 동일합니다.  
{: .notice--warning}  

## Viewing Error Data in the Error Browser

![2023-08-02-view-error-browser.png]({{site.baseurl}}/assets/images/2023-08-02-view-error-browser.png){: .align-center}  

To investigate the DRC error markers in the GUI, use the Menu item -> view error browser. This is the same error browser you've used previously when you checked for routing DRC errors after detailed routing.  
DRC 오류 마커를 GUI에서 확인하려면 Menu 항목 -> View Error Browser를 사용합니다. 이것은 상세한 라우팅 후 라우팅 DRC 오류를 확인할 때 사용한 이전과 동일한 오류 브라우저입니다.  
{: .notice--warning}  

## Filtering Error Data

![2023-08-02-filter-error-data.png]({{site.baseurl}}/assets/images/2023-08-02-filter-error-data.png){: .align-center}  

You can filter the error data by error types, layers, and net types to narrow down the scope of DRC errors that are displayed in the error browser.  
{: .notice--warning}  

## Metal Fill Insertion

![2023-08-02-metal-fill-insertion.png]({{site.baseurl}}/assets/images/2023-08-02-metal-fill-insertion.png){: .align-center}  

Full-chip metal-fill insertion and removal can be done with ICV using two different flows. The pattern-based flow takes a user-specified runset, and the track-based fill flow automatically generates the runset. ICV supports a specific set of technologies from different foundries for the automatic track-based flow. There is also a "generic" mode that will work with any technology. Timing-driven metal fill is supported, as well as an auto-eco mode, that allows you to specify a threshold of routing changes. If routing changes are less than that threshold, then ECO metal fill is done. Otherwise, full metal fill is triggered.  
ICV를 사용하여 전체 칩의 금속 채우기(메탈필) 삽입과 제거를 두 가지 다른 플로우로 수행할 수 있습니다. 패턴 기반 플로우는 사용자가 지정한 runset을 사용하며, 트랙 기반 메탈필 플로우는 자동으로 runset을 생성합니다. ICV는 다양한 파운드리의 특정 기술을 지원하며, 자동 트랙 기반 플로우에 대해 "일반적인" 모드도 지원합니다. 타이밍 기반 메탈필과 함께 라우팅 변경에 대한 임계값을 지정할 수 있는 자동 ECO 모드도 지원합니다. 라우팅 변경이 해당 임계값보다 적으면 ECO 메탈필이 수행되고, 그렇지 않으면 전체 메탈필이 실행됩니다.  
{: .notice--warning}  

## Viewing and Editing Metal Fill

Metal fill viewing can be toggled in the layout window using the Fill Cell object. These fill shapes all have a shape use attribute of "area fill". A "fill cell" includes all the fill shapes. By default, the fill cell is instantiated at the top level and called FILL_INST_0, as shown. To query fill cells, use the `get_fill_cells` command, to remove them, use `remove_fill_cells`, as shown in the notes. Alternatively, you can use the GUI to selectively remove individual shapes.  
레이아웃 창에서 메탈필을 보려면 "Fill Cell" 오브젝트를 사용하여 토글할 수 있습니다. 이 메탈필 모든 형태들은 "area fill"이라는 모양 사용 속성을 가지고 있습니다. "Fill Cell"에는 모든 메탈필 형태들이 포함됩니다. 기본적으로 "Fill Cell"은 최상위 레벨에서 인스턴스화되며 "FILL_INST_0"로 불립니다. 메탈필 셀들을 조회하려면 "`get_fill_cells`" 명령어를 사용하고, 제거하려면 "`remove_fill_cells`" 명령어를 사용할 수 있습니다. 또는 GUI를 사용하여 개별적으로 형태들을 선택적으로 제거할 수도 있습니다.  
{: .notice--warning}  

## Metal Fill Example Script

![2023-08-02-metal-fill-example.png]({{site.baseurl}}/assets/images/2023-08-02-metal-fill-example.png){: .align-center}  

The `signoff_create_metal_fill` command performs the ICV based metal filling. For signoff metal fill, all layers in the original GDSII or OASIS databases (not LEF) are preferred. You can use the application options shown to use the design or layout views in the referenced CLIBs, or use the GDSII or OASIS files directly. To prevent metal fill from introducing timing failures, use the threshold option as shown. Any nets with slack less than this value will be considered critical, and the timing will be preserved on them by preventing fill shapes within the minimum spacing of these nets.  
`signoff_create_metal_fill` 명령은 ICV 기반 메탈필을 수행합니다. 서명(Signoff) 메탈필의 경우, 원래의 GDSII 또는 OASIS 데이터베이스의 모든 레이어들 (LEF 제외)을 사용하는 것이 선호됩니다. 표시된 애플리케이션 옵션들을 사용하여 참조된 CLIB의 디자인 또는 레이아웃 뷰를 사용하거나 GDSII 또는 OASIS 파일들을 직접 사용할 수 있습니다. 타이밍 실패가 발생하지 않도록 하려면, threshold 옵션을 사용합니다. 이 값보다 슬랙이 작은 어떤 넷들은 중요한 것으로 간주되며, 이러한 넷들의 최소 스페이싱 내에 메탈필 형태들이 생성되지 않도록하여 타이밍을 보존합니다.  
{: .notice--warning}  
