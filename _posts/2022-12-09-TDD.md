---
title: "TDD: 테스트 주도 개발"
excerpt: "안정감을 주는 코드 작성 방법"
date: 2022-12-09 01:00:00 +0900
classes: wide
header:
  overlay_image: /assets/images/unsplash-emile-perron.jpg
  overlay_filter: 0.5
  caption: "Photo by [**Emile Perron**](https://unsplash.com/@emilep) on [**Unsplash**](https://unsplash.com/)"
categories:
  - Robust Python
---

## 1. 좋은 코드

### 엔지니어링

소프트웨어는 과학일까 엔지니어링일까? 과학은 무언가를 밝혀내는 것, 엔지니어링은 무언가 해결하는 것.  
엔지니어링은 자연의 자원을 인류의 용도를 위해 최적 변환하는 것, 즉 수단에 가깝다. 

예를 들어 클린코드 같은 경우 지키면 좋은 기준들로 구성되어 있지만 그것에 매몰되어선 안된다고 생각한다. 
해결해야하는 문제에 따라 코드의 기준이 변경될 수 있다.

#### 패턴

- 알려진 문제의 일반적이고 재사용할 수 있는 해결법
- 프로그래머는 고유한 문제를 풀어야 한다.
- 고유한 문제는 좀 더 작은 하위 기술 문제를 가진다.
- 이 작은 기술 문제들 중 많은 일부는 과거 어디에 선가 여러 번 반복되고 해결된 적이 있다.

> "Patterns always have two parts: the how and the when."
> Martin Fowler

패턴은 일종의 치료약과 같다. 앓고 있는 병에 맞지 않는 약은 오히려 독이 된다. 
맞지 않는 상황에서 패턴을 사용하면 역효과가 날 수 있다.

- 현장은 무균실이 아니라 야전이다.
- 프로그래밍은 협업이다.
- 시스템은 연결된다.
- 도구 상자에 다양한 도구를 채우자.
- 엔지니어링은 거래(trade-off)다. 

#### 근육기억

반복되는 문제 해결에 비용이 많이 쓰인다면 <span class="custom-highlight"> **연습하고, 연습하고 연습해서 생각의 비용을 줄어들도록 뇌에 새겨라.**</span>


## 2. 테스트 주도 개발 기초

### 코드 기능 명세

모든 프로그램 코드는 입력과 출력을 갖고 특정 입력에 대해 기대하는 출력이 있습니다. 이런 기대 동작들을 코드 명세 또는 요구 사항이라고 부릅니다. 프로그래머가 코드 명세에 집중을 유지해야 하는 이유를 알아봅시다.

#### 도메인

소프트웨어는 문제를 푸는 도구이다. 도메인은 소프트웨어가 풀어야 할 문제가 정의되는 공간이다. 문제를 충분히 이해하지 못하면 문제를 푸는 도구를 잘 만들 수 없다.

#### 비즈니스 시스템의 도메인 지식 흐름

비즈니스 전문가 → 분석가 → 프로그래머 → 컴퓨터

1. **비즈니스 전문가**\
   - 문제를 가장 잘 이해
   - 시스템이 투영해야 할 핵심 지식의 원천
   - 문제 설명력 부족(지식의 저주)
   - 풀이도 가장 잘 이해한다고 착각(문제를 말해야 할 때 풀이를 말하려는 경향을 가짐)
2. **분석가**
   - 비즈니스 전문가로부터 시스템 요구사항을 발굴
   - 발굴된 요구사항의 오류 탐색
   - 발견된 문제점을 구현 작업 전에 협업을 통해 해결
3. **프로그래머**
   - 정제된 기능 명세를 아키텍처와 코드로 번역(제품 제작 과정 중 비용이 가장 큰 작업)
   - 끊임없는 설계 결정
   - 지식 흐름 과정의 마지막 인간
4. **컴퓨터**
   - 코드를 통해 프로그래머로부터 지식을 전달받음
   - 철저히 수동적, 융통성 없음

#### 프로그래머와 기능 명세

컴퓨터는 스스로 설계를 결정하지 않기 때문에 프로그래머가 도메인 지식을 컴퓨터에 전달할 때엔 모든 요소들이 명확히 결정될 수 밖에 없음.  
충분히 명확한 도메인 지식을 확보하지 못했다면 지식 흐름 상류에 지식 보강을 요청해야 함.  
하지만 어떤 프로그래머는 스스로 결정을 내림 → 도메인 지식 투영에 오차 발생, 무책임하고 위험한 도박  

#### 단위 테스트 작성 실습

통계 소프트웨어를 만든다고 하자. 분산을 계산하는 기능을 개발해야 하는데, `[1, 2, 3, 4, 5, 6]`의 분산은 `3.5`라는 명세를 받았다고 가정하자. 

```python
import sys

s = []
for v in sys.argv[1:]:
  s.append(float(v))

mean = sum(s) / len(s)

sum_of_squares = 0.0

for v in s:
  sum_of_squares += (v - mean) ** 2

variance = sum_of_squares / (len(s) - 1)

print(f'분산: {variance}')
```

위와 같이 구현 후 배포를 했다. 버그 발생 → 주어진 데이터가 2개 이하일 때는 분산 계산할 수 없으므로 오류 메시지 출력해야 함! 충분하지 않은 명세로 인해 버그가 발생하였다.

### 테스트 기법

#### 수동 테스트

- 품질 담당자가 UI를 사용해 기능을 검증
- 최종 사용자의 사용 경험과 가장 비슷하게 검증
- 실행 비용이 높고 결과의 변동이 큼
- 가장 온전한 코드 실행
- 인수 테스트

#### 소프트웨어 회귀(Software regression)

소프트웨어 회귀란 소프트웨어가 어떤 이벤트(환경 변화) 이후로 동작하지 않는 버그를 뜻한다. 소프트웨어의 기능은 시간이 지나면서 대부분 늘어나게 마련이다. 코드 변경은 기존 동작하던 기능들에도 영향을 줄 수 있다. 그러므로 신규 동작 추가 시 기존 동작 기능들에 대한 재검증도 필요하나, 필요로 하는 수동 테스트가 계속해서 늘어나게 된다.

#### 테스트 자동화

1. 기능을 검증하는 코드를 작성
2. 테스트 코드 작성 비용이 소비되지만 실행 비용이 낮고 겨로가의 신뢰도가 높음
3. 테스트 코드 작성과 관리가 프로그래머 역량에 크게 영향 받음

#### 인수 테스트 특징

1. 배치된 시스템을 대상으로 검증
2. 전체 시스템 이상 여부 신뢰도가 높음
3. 높은 비용(작성비용/관리비용/실행비용)
4. 피드백 품질이 낮음(현상은 드러나지만 원인은 숨겨짐)

#### 단위 테스트 특징

1. 시스템의 일부(하위 시스템)을 대상으로 검증
2. 낮은 비용(작성비용/관리비용/실행비용)
3. 높은 피드백 품질(오류 위치 파악 쉬움)
4. 전체 시스템 이상 여부 신뢰도가 낮음
   - 단위 테스트가 성공해도 시스템은 이상이 있을 수 있음

### 코드 분해

#### 문제의 크기

모든 사람은 한 번에 다룰 수 있는 문제의 크기에 제한이 있다.  
프로그래머는 더 큰 문제를 자주 마주한다.  
시스템의 크기는 점점 커지기 마련이다.  
큰 문제는 작은 문제로 분해할 수 있다.  
작은 문제의 일부는 반복된다.  

#### 코드 재사용

1. 반복되는 문제의 풀이는 재사용 가능
2. 소프트웨어 개발 비용 절감(엔지니어링)

#### 모듈화

- 분해
  - 큰 시스템은 더 작은 하위 시스템으로 분해 가능
  - 교체 가능
- 조립
  - 작은 시스템은 더 큰 상위 시스템으로 조립 가능
  - 모듈 재사용
  - 라이브러리
- 단위 테스트

### 단위 테스트

단위 테스트는 테스트 주도 개발의 가장 중요한 도구입니다. 기존 코드의 동작을 검증하는 단위 테스트를 작성해 봅니다.

아래와 같은 코드를 인수받았다고 생각하자.

```python
# utils.py
def refine_text(s: str):
    """문자열에 공백 문자가 중복되어있을 때 합쳐주는 코드"""
    return s.replace('    ', ' ').replace('  ', ' ')
```

```python
# test_utils.py
import pytest
import utils

@pytest.mark.parametrize(
    'test_input,expected',
    [
        ('hello  world', 'hello world'),
        ('hello   world', 'hello world'), # 테스트 실패 AssertionError: assert 'hello  world' == 'hello world'
        ('hello    world', 'hello world'),
    ]
)
def test_refine_text(test_input: str, expected: str):
    assert utils.refine_text(test_input) == expected
```

### 테스트 우선 개발

#### 테스트 코드

1. 가시적이고 구체적인 목표
2. 자가검증
3. 반복실행 가능하다
4. 클라이언트 입장에서 작성됨

운영 코드보다 **테스트 코드를 먼저 작성**한다.

1. 명확하고 검증 가능한 목표를 설정한 후 목표를 달성
2. 코딩에 앞선 목표 설정이 강제되는 프로세스를 가짐
3. 프로그래머는 자신이 풀어야 할 문제를 구체적으로 이해해야 함
