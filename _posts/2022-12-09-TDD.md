---
title: "TDD: 테스트 주도 개발"
excerpt: "안정감을 주는 코드 작성 방법"
date: 2022-12-09 01:00:00 +0900
classes: wide
header:
  overlay_image: /assets/images/unsplash-emile-perron.jpg
  overlay_filter: 0.5
  caption: "Photo by [**Emile Perron**](https://unsplash.com/@emilep) on [**Unsplash**](https://unsplash.com/)"
categories:
  - Robust Python
---

## 1. 좋은 코드

### 엔지니어링

소프트웨어는 과학일까 엔지니어링일까? 과학은 무언가를 밝혀내는 것, 엔지니어링은 무언가 해결하는 것.  
엔지니어링은 자연의 자원을 인류의 용도를 위해 최적 변환하는 것, 즉 수단에 가깝다.  

예를 들어 클린코드 같은 경우 지키면 좋은 기준들로 구성되어 있지만 그것에 매몰되어선 안된다고 생각한다.  
해결해야하는 문제에 따라 코드의 기준이 변경될 수 있다.

#### 패턴

- 알려진 문제의 일반적이고 재사용할 수 있는 해결법
- 프로그래머는 고유한 문제를 풀어야 한다.
- 고유한 문제는 좀 더 작은 하위 기술 문제를 가진다.
- 이 작은 기술 문제들 중 많은 일부는 과거 어디에 선가 여러 번 반복되고 해결된 적이 있다.

> "Patterns always have two parts: the how and the when."
> Martin Fowler

패턴은 일종의 치료약과 같다. 앓고 있는 병에 맞지 않는 약은 오히려 독이 된다.  
맞지 않는 상황에서 패턴을 사용하면 역효과가 날 수 있다.

- 현장은 무균실이 아니라 야전이다.
- 프로그래밍은 협업이다.
- 시스템은 연결된다.
- 도구 상자에 다양한 도구를 채우자.
- 엔지니어링은 거래(trade-off)다.  

#### 근육기억

반복되는 문제 해결에 비용이 많이 쓰인다면 <span class="custom-highlight">**연습하고, 연습하고 연습해서 생각의 비용을 줄어들도록 뇌에 새겨라.**</span>

## 2. 테스트 주도 개발 기초

### 코드 기능 명세

모든 프로그램 코드는 입력과 출력을 갖고 특정 입력에 대해 기대하는 출력이 있습니다. 이런 기대 동작들을 코드 명세 또는 요구 사항이라고 부릅니다. 프로그래머가 코드 명세에 집중을 유지해야 하는 이유를 알아봅시다.

#### 도메인

소프트웨어는 문제를 푸는 도구이다. 도메인은 소프트웨어가 풀어야 할 문제가 정의되는 공간이다. 문제를 충분히 이해하지 못하면 문제를 푸는 도구를 잘 만들 수 없다.

#### 비즈니스 시스템의 도메인 지식 흐름

비즈니스 전문가 → 분석가 → 프로그래머 → 컴퓨터

1. **비즈니스 전문가**\
   - 문제를 가장 잘 이해
   - 시스템이 투영해야 할 핵심 지식의 원천
   - 문제 설명력 부족(지식의 저주)
   - 풀이도 가장 잘 이해한다고 착각(문제를 말해야 할 때 풀이를 말하려는 경향을 가짐)
2. **분석가**
   - 비즈니스 전문가로부터 시스템 요구사항을 발굴
   - 발굴된 요구사항의 오류 탐색
   - 발견된 문제점을 구현 작업 전에 협업을 통해 해결
3. **프로그래머**
   - 정제된 기능 명세를 아키텍처와 코드로 번역(제품 제작 과정 중 비용이 가장 큰 작업)
   - 끊임없는 설계 결정
   - 지식 흐름 과정의 마지막 인간
4. **컴퓨터**
   - 코드를 통해 프로그래머로부터 지식을 전달받음
   - 철저히 수동적, 융통성 없음

#### 프로그래머와 기능 명세

컴퓨터는 스스로 설계를 결정하지 않기 때문에 프로그래머가 도메인 지식을 컴퓨터에 전달할 때엔 모든 요소들이 명확히 결정될 수 밖에 없음.  
충분히 명확한 도메인 지식을 확보하지 못했다면 지식 흐름 상류에 지식 보강을 요청해야 함.  
하지만 어떤 프로그래머는 스스로 결정을 내림 → 도메인 지식 투영에 오차 발생, 무책임하고 위험한 도박  

#### 단위 테스트 작성 실습

통계 소프트웨어를 만든다고 하자. 분산을 계산하는 기능을 개발해야 하는데, `[1, 2, 3, 4, 5, 6]`의 분산은 `3.5`라는 명세를 받았다고 가정하자.

```python
import sys

s = []
for v in sys.argv[1:]:
  s.append(float(v))

mean = sum(s) / len(s)

sum_of_squares = 0.0

for v in s:
  sum_of_squares += (v - mean) ** 2

variance = sum_of_squares / (len(s) - 1)

print(f'분산: {variance}')
```

위와 같이 구현 후 배포를 했다. 버그 발생 → 주어진 데이터가 2개 이하일 때는 분산 계산할 수 없으므로 오류 메시지 출력해야 함! 충분하지 않은 명세로 인해 버그가 발생하였다.

### 테스트 기법

#### 수동 테스트

- 품질 담당자가 UI를 사용해 기능을 검증
- 최종 사용자의 사용 경험과 가장 비슷하게 검증
- 실행 비용이 높고 결과의 변동이 큼
- 가장 온전한 코드 실행
- 인수 테스트

#### 소프트웨어 회귀(Software regression)

소프트웨어 회귀란 소프트웨어가 어떤 이벤트(환경 변화) 이후로 동작하지 않는 버그를 뜻한다. 소프트웨어의 기능은 시간이 지나면서 대부분 늘어나게 마련이다. 코드 변경은 기존 동작하던 기능들에도 영향을 줄 수 있다. 그러므로 신규 동작 추가 시 기존 동작 기능들에 대한 재검증도 필요하나, 필요로 하는 수동 테스트가 계속해서 늘어나게 된다.

#### 테스트 자동화

1. 기능을 검증하는 코드를 작성
2. 테스트 코드 작성 비용이 소비되지만 실행 비용이 낮고 겨로가의 신뢰도가 높음
3. 테스트 코드 작성과 관리가 프로그래머 역량에 크게 영향 받음

#### 인수 테스트 특징

1. 배치된 시스템을 대상으로 검증
2. 전체 시스템 이상 여부 신뢰도가 높음
3. 높은 비용(작성비용/관리비용/실행비용)
4. 피드백 품질이 낮음(현상은 드러나지만 원인은 숨겨짐)

#### 단위 테스트 특징

1. 시스템의 일부(하위 시스템)을 대상으로 검증
2. 낮은 비용(작성비용/관리비용/실행비용)
3. 높은 피드백 품질(오류 위치 파악 쉬움)
4. 전체 시스템 이상 여부 신뢰도가 낮음
   - 단위 테스트가 성공해도 시스템은 이상이 있을 수 있음

### 코드 분해

#### 문제의 크기

모든 사람은 한 번에 다룰 수 있는 문제의 크기에 제한이 있다.  
프로그래머는 더 큰 문제를 자주 마주한다.  
시스템의 크기는 점점 커지기 마련이다.  
큰 문제는 작은 문제로 분해할 수 있다.  
작은 문제의 일부는 반복된다.  

#### 코드 재사용

1. 반복되는 문제의 풀이는 재사용 가능
2. 소프트웨어 개발 비용 절감(엔지니어링)

#### 모듈화

- 분해
  - 큰 시스템은 더 작은 하위 시스템으로 분해 가능
  - 교체 가능
- 조립
  - 작은 시스템은 더 큰 상위 시스템으로 조립 가능
  - 모듈 재사용
  - 라이브러리
- 단위 테스트

### 단위 테스트

단위 테스트는 테스트 주도 개발의 가장 중요한 도구입니다. 기존 코드의 동작을 검증하는 단위 테스트를 작성해 봅니다.

아래와 같은 코드를 인수받았다고 생각하자.

```python
# utils.py
def refine_text(s: str):
    """문자열에 공백 문자가 중복되어있을 때 합쳐주는 코드"""
    return s.replace('    ', ' ').replace('  ', ' ')
```

```python
# test_utils.py
import pytest
import utils

@pytest.mark.parametrize(
    'source,expected',
    [
        ('hello  world', 'hello world'),
        ('hello   world', 'hello world'), # 테스트 실패 AssertionError: assert 'hello  world' == 'hello world'
        ('hello    world', 'hello world'),
    ]
)
def test_refine_text(source: str, expected: str):
    assert utils.refine_text(source) == expected
```

### 테스트 우선 개발

#### 테스트 코드

1. 가시적이고 구체적인 목표
2. 자가검증
3. 반복실행 가능하다
4. 클라이언트 입장에서 작성됨

운영 코드보다 **테스트 코드를 먼저 작성**한다.

1. 명확하고 검증 가능한 목표를 설정한 후 목표를 달성
2. 코딩에 앞선 목표 설정이 강제되는 프로세스를 가짐
3. 프로그래머는 자신이 풀어야 할 문제를 구체적으로 이해해야 함

### 정리된 코드

#### 작업 환경 정리

- **생산성**: 정리된 환경과 어지럽혀진 환경에서의 작업 생산성 차이
- **지속성**: 작업 환경의 생산성이 일정 수준 미만으로 떨어지면 더 이상 그 환경에서 작업 진행은 불가능
- **코드는 작업 환경이자 작업 결과물**

#### Re-factoring(리팩터링)

의미를 유지하며 코드베이스를 정리하는 작업  
→ 의미가 유지되는 것을 **어떻게 확신할 것인가?**  
→ 우리에게는 테스트 코드가 있다.  

### 테스트 주도 개발

#### 테스트 실패

1. 구체적인 하나의 요구사항을 검증하는 하나의 테스트를 추가
2. 추가된 테스트가 실패하는지 확인

#### 테스트 성공

1. 추가된 테스트를 비롯해 모든 테스트가 성공하도록 운영 코드를 변경
2. 테스트 성공은 요구사항 만족을 의미(코딩의 가장 중요한 임무)
3. 테스트 성공을 위한 **최소한의 변경**(가장 중요한 임무를 가장 빠르게 완수)
테스트가 없는 코드는 작성해선 안된다.

#### 켄트 벡의 설계 규칙

- 테스트를 통과한다.
- 의도를 노출한다.
- 중복을 제거한다.
- 요소를 최소화한다.

#### 테스트 주도 개발 흐름

![테스트 주도 개발 흐름]({{site.baseurl}}/assets/images/2022-12-16-tdd-flow.drawio.svg){: .align-center}

#### 테스트 주도 개발 고려사항

항상 TDD를 적용해야할까?

![테스트 주도 개발 흐름]({{site.baseurl}}/assets/images/2022-12-16-tdd-cost.drawio.svg){: .align-center}

하지만 우리의 TDD 역량을 키우거나 툴을 이용하여 TDD 비용을 줄일 수도 있다.

### 프로그래머 피드백

#### 기대 출력 피드백

1. 사용자 피드백: 사용자가 직접 코드를 사용한 후 경험한 버그/불만 제보
2. Quality Assurance: 전문 인적 자원에 의한 인수 테스트
3. 프로그래머 테스트: 프로그래머가 직접 피드백 장치를 준비
4. 도구 피드백: 컴파일 오류, 정적 검사 등 프로그래머가 사용하는 도구가 제공하는 피드백

#### 오버엔지니어링

프로그래머는 요구사항 명세에 명확히 지정되지 않은 성능 달성이나 구현 설계 품질 개선에 빠져드는 경향을 가짐.  
이런 목표는 그 자체로 나쁜 것이 아니지만 지나치면 더 중요한 목적, 기능 요구사항에 써야 할 자원을 불필요하게 낭비하게 됨.  

테스트 주도 개발은 가장 중요한 목표를 우선 달성하도록 유도하며 오버엔지니어링에 빠졌음을 느낄 때 **안심하고 다음으로 나아갈 수 있도록 피드백**을 제공.

#### 핵심은 피드백

테스트 주도 개발의 핵심은 정해진 절차가 아니라 <span class="custom-highlight">**짧은 주기로 지속되는 피드백**</span>  

피드백에 기반해 안정적으로 지식과 코드를 늘려 나가는 것이 목적

## 토이 프로젝트

간단한 게임을 만들어보며 배운 것을 적용해보자.

### 게임 설계

- 1부터 100까지의 임의의 정수를 맞추는 게임
- 플레이어가 숫자를 입력하다면 정답보다 큰지/작은지/일치하는지 출력해준다.
- 단일 플레이어 모드와 다중 플레이어 모드 지원
  - 단일 플레이어 모드 라운드가 종료되면 총 시도를 출력
  - 다중 플레이어 모드 라운드가 종료되면 승자를 출력

#### 게임 진행 흐름도

![게임 진행 흐름도]({{site.baseurl}}/assets/images/2022-12-16-tdd-toy-flow.drawio.svg){: .align-center}

#### 게임 모델 설계

![게임 모델 설계]({{site.baseurl}}/assets/images/2022-12-16-tdd-toy-model.drawio.svg){: .align-center}

#### 게임 루프 설계

![게임 모델 설계]({{site.baseurl}}/assets/images/2022-12-16-tdd-toy-loop.drawio.svg){: .align-center}

#### Base 코드

TDD 시작하기 앞서 기본 코드 작성하였다.  

[github 링크](https://github.com/hvppycoding/guessnumber/tree/basecode)

```text
guessnumber
├─ guessnumber
│  ├─ app
│  │  ├─ app.py
│  │  ├─ randomgenerator.py
│  │  └─ __init__.py
│  ├─ model
│  │  ├─ appmodel.py
│  │  ├─ positiveintegergenerator.py
│  │  └─ __init__.py
│  └─ __init__.py
├─ README.md
├─ setup.cfg
├─ setup.py
└─ tests
```

#### Single Player 모드

TDD를 통해 Single Player 모드를 구현하였다.

[github 링크](https://github.com/hvppycoding/guessnumber/tree/singleplayer)

정의한 테스트를 모두 통과하는 것을 확인할 수 있다.

![Single Player 테스트 결과]({{site.baseurl}}/assets/images/2023-01-10-tdd-singleplayer-test.png){: .align-center}

#### Multi Player 모드

Multi Player 모드까지 모두 구현하였다.  

[github 링크](https://github.com/hvppycoding/guessnumber/tree/multiplayer)

패키지 설치 후 `guessnumber` 커맨드를 통해 실행할 수 있다.  
다음은 플레이 화면이다.  

![Multi Player 플레이 결과]({{site.baseurl}}/assets/images/2023-01-12-tdd-multiplayer-play.png){: .align-center}

## 3. 테스트 주도 개발의 깊은 곳

### 인터페이스와 구현

추상화란?

> "The essence of abstraction is **preserving information** that is relevant in a given context, and **forgetting information** that is **irrelevant** in that context"  
> *John Vogel Guttag*

#### 협력과 계약

- 대부분의 코드는 다른 코드와 **협력**한다.
- 협력에 필요한 것은 '어떻게'가 아닌 **'무엇'**
- 인터페이스
  - '무엇'을 표현
  - 클라이언트 코드에게 반드시 필요한 정보
  - 협력하는 코드 사이의 **계약**
  - **추상화**의 결과

#### 정보 숨김

- David Lorge Parnas의 1971년 논문

- 효과적인 모듈화
  - 조직 간 의사소통 최소화
  - 변경 여파 최소화
  - 시스템 이해 도움

- 공개된 설계 결정과 숨겨진 설계 결정
  - 어려운 설계 결정과 변경될 것 같은 설계 결정을 숨겨라.

> 대부분의 시스템 정보는 대부분의 프로그래머에게 숨겨지는 것이 도움된다.  
> ...  
> 대신 어려운 설계 결정이나 변경 될 가능성이 있는 설계 결정 목록으로 시작하는 것이 좋다.  
> 그런 다음 각 모듈은 이러한 결정을 다른 모듈롸부터 숨기도록 설계된다.  

