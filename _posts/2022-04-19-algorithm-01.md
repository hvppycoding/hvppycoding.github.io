---
title: "알고리즘 I - 문제 해결 시작하기"
excerpt: "프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략"
date: 2022-04-19 20:00:00 +0900
header:
  overlay_image: /assets/images/unsplash-thomas-t-math.jpg
  overlay_filter: 0.5
  caption: "Photo by [**Thomas T**](https://unsplash.com/@pyssling240) on [**Unsplash**](https://unsplash.com/)"
categories:
  - Algorithm
---
**Notice:** 본 포스트는 『프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략』 책을 공부하며 쓴 글입니다.
{: .notice--info}
# I. 문제 해결 시작하기
단순한 알고리즘의 설명만으로 알고리즘이 생겨난 배경에 공감하고, 문제를 풀기 위한 통찰을 배우기 힘들다.  
지식을 진정 자신의 것으로 만들어 활용하기 위해서는 학문이 발전하는 과정에서 일어난 발견과 깨달음을 학생이 경험할 수 있어야 한다.  
프로그래밍 대회는 이런 경험과 깨달음을 얻기 위한 좋은 통로이다.  

## 01. 문제 해결과 프로그래밍 대회
### 1.1 도입
**프로그래밍은 문제 해결이다.** 프로그래머는 자신이 사용하고 있는 언어의 특성, 프로그램이 동작할 하드웨어와 운영체제에 관한 지식, 사용하고 있는 라이브러리에 대한 지식이 필요하다.  

### 1.5 대회 준비를 위한 조언
#### 가능한 한 많은 문제 풀기
 프로그래밍 대회를 제대로 준비하기 위해 공부해야할 주제는 굉장히 많다. 사람들은 공부해야 할 주제의 다양성이 압도되어 교과서와 다른 자료들을 최대한 많이 읽으면서 배경 지식을 늘리는 데 주력하는 실수를 하기 쉽다. 그러나 복잡한 알고리즘 하나 더 아는 것보다는 <span class="custom-highlight">**실제로 자신이 아는 것을 이용해 문제를 풀 수 있는 능력이 훨씬 더 중요하다.**</span> 프로그래밍 대회에서는 결국 자신이 작성한 프로그램으로만 경쟁하기 때문에 아무리 많은 지식이 있어도 그것을 이용해 프로그램을 작성할 수 없으면 아무런 소용이 없다. 이런 경험과 능력은 실제 문제를 직접 풀어보는 과정에서 기를 수 있으므로 초심자들은 아래 표에 소개된 중요 주제들을 먼저 공부한 뒤에 많은 문제를 풀어보자.

| 장 번호 | 장 제목 |
|--------|---------|
| 2 | 문제 해결 전략 |
| 3 | 코딩과 디버깅 |
| 4 | 알고리즘의 시간 복잡도 분석 |
| 6 | 무식하게 풀기 |
| 7 | 분할 정복 |
| 8 | 동적 계획법 |
| 18 | 선형 자료 구조 |
| 19 | 큐와 스택, 데크 |
| 21 | 트리의 구현과 순회 |
| 22 | 이진 검색 트리 |
| 23 | 우선순위 큐와 힙 |
| 27 | 그래프의 표현과 정의 |
| 28 | 그래프의 깊이 우선 탐색 |
| 29 | 그래프의 너비 우선 탐색 |
| 30 | 최단 경로 알고리즘 |

<small>표. 입문자를 위한 커리큘럼</small>

## 02. 문제 해결 개관

### 2.1 도입
무작정 알고리즘을 외우고 문제를 푼다고 해서 문제 해결 실력이 쌓이는 것은 아니다. 좋은 문제 해결자가 되기 위해서는 문제를 푸는 기술을 연마해야 한다. 이를 위해서는 자신이 문제를 어떤 방식으로 해결하는지를 의식하고 개선점을 파악해야 한다. 골프를 배우는 과정에 비유해보면, 채를 휘둘러 공을 치는 것은 누구나 할 수 있다. 그리고 여러 번 공을 치다 보면 운이 좋게 정확하게 맞을 때도 있다. 하지만 무작정 공을 많이 친다고 해서 실력이 나아지는 것은 아니다. 실력을 늘리기 위해서는 채를 휘두르는 과정을 여러 부분으로 나눠 보고 각 과정의 개선점을 끊이 없이 파악해야 한다.  
마찬가지로, 문제 해결 과정도 여러 단계로 나눠보고 각 단계를 더 잘하기 위한 기술들을 소개한다.  

### 2.2 문제 해결 과정

```
1. 문제를 읽고 이해한다.
2. 문제를 익숙한 용어로 재정의한다.
3. 어떻게 해결할지 계획을 세운다.
4. 계획을 검증한다.
5. 프로그램으로 구현한다.
6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.
```

#### 1단계: 문제를 읽고 이해하기
문제 설명을 자세히 읽으며 문제가 원하는 바를 완전히 이해하는 과정이 필요하다. 사소한 제약 조건을 잘못 이해하면 풀 수 없게 되는 문제들이 많다. 
조급한 마음에 그림과 입출력 예제를 보고 문제를 유추하기 십상이다. 그러나 이와 같은 행동은 반드시 언젠가 큰 대가를 치루게 된다.

#### 2단계: 재정의의 추상화
문제를 자신의 언어로 풀어쓰는 과정이 필요하다. 추상화를 통해 현실 세계의 개념을 우리가 다루기 쉬운 수학적/전산학적 개념으로 옮겨 표현해야 한다.  
문제의 본질을 어떻게 재구성하느냐에 따라 같은 문제라도 쉽게 해결할 수도, 어렵게 해결할 수도 있다.

#### 3단계: 계획 세우기
문제를 어떻게 해결할지 계획을 세운다. 이 과정에서 문제를 어떤 방식으로 해결할지 결정하고, 사용할 알고리즘과 자료 구조를 선택한다.  
사실상 이 부분이 문제 해결에서 가장 중요한 단계이며, 해결책이 곧장 떠오르지 않는 어려운 문제의 경우 이 과정에서 가장 많은 고민을 하게 된다.

#### 4단계: 계획 검증하기
계획을 세운 후 곧장 키보들르 잡아서는 안된다. 구현을 시작하기 전에 계획을 검증하는 과정을 거쳐야한다.
우리의 설계가 요구 조건을 정확히 수행하는지 증명하고, 수행 시간과 메모리가 제한 내에 들어가는지 확인해야 한다.

#### 5단계: 계획 수행하기
아무리 천재적인 알고리즘이라도 구현이 부정확하면 동작할 수 없다.

#### 6단계: 회고하기
문제 해결에 당장 직접적인 영향은 없지만 장기적으로 가장 큰 영향을 미치는 단계이다.  
문제를 한 번만 풀어서는 그 문제에서 배울 수 있는 것들을 다 배우지 못하는 경우가 더 많다. 두 번째로 문제를 풀 때는 더 효율적인 알고리즘을 찾거나 간결한 코드를 작성할 수도 있고, 같은 알고리즘을 유도할 수 있는 더 직관적인 방법을 찾을 수도 있다.  
가장 좋은 회고 방법은 문제를 풀 때마다 코드와 함께 자신의 접근 방법을 기록으로 남기는 것이 좋다. 한 번에 맞추지 못한 경우에는 오답 원인도 꼭 적자. 대개 같은 실수를 반복하는 경우가 많은데, 오답 노트를 적다 보면 자주 틀리는 부분을 알게 되고 실수를 줄일 수 있게 된다.  
회고를 위한 또 다른 좋은 방법은 같은 문제를 해결한 다른 사람의 코드를 보는 것이다. 다른 사람들이 다른 방식으로 문제를 해결하는 것을 보면 생각하지 못했던 통찰을 얻을 수도 있다.


### 2.3 문제 해결 전략
우리가 사용할 수 있는 전략들을 소개한다.
#### 직관과 체계적인 접근
직관은 해당 문제를 해결하는 알고리즘의 현태를 짐작할 수 있게 한다. 하지만 직관적으로 떠오르지 않는 막막한 문제들에 대해서 체계적으로 접근하는 것도 필요하다.

#### 체계적인 접근을 위한 질문들
많은 문제에 적용될 수 있는 강력한 질문들부터 그 사용처가 제한되는 질문 순서로 배열되어 있다. 

#### <span class="custom-highlight">비슷한 문제를 풀어본 적이 있던가?</span>
형태가 비슷하거나 관련된 문제를 풀어 본 적이 있다면 이전에 적용했던 방법과 비슷한 접근 방법을 사용할 것이라고 예측할 수 있다. 이를 위해선 문제 해결의 원리를 완전히 이해하고 변형할 수 있어야 한다. 예를 들어 철도망 위에서 두 도시를 잇는 가장 짧은 경로를 찾는 문제를 풀었다. 하지만 다음과 같은 변형 문제들은 어떨까?
- 한 도시를 두 번 방문하지 않으면서 가장 긴 경로를 찾는 문제
- 기차를 네 번 이하로 갈아타면서 가장 짧은 경로를 찾는 문제
- 역 간 운행 거리 중 가장 긴 구간이 가장 짧은 경로를 찾는 문제
- 역 간 운행 거리 중 가장 짧은 구간이 가장 긴 경로를 찾는 문제
- 가장 긴 구간과 가장 짧은 구간의 길이 차이가 가장 적인 경로를 찾는 문제
이 문제들 중에는 최단 경로 문제를 응용해서 풀 수 있는 문제도 있고, 아닌 문제도 있다. 이를 구분하기 위해서는 최단 경로 알고리즘을 단순히 알고 있는 것에서 멈추지 않고 그 동작 과정과 원리를 완전히 이해하고 있어야 한다.

꼭 형태가 비슷하지 않더라도 문제의 목표가 같은 경우도 있다. 예를 들어 어떤 사건의 발생 확률이나 경우의 수를 계산하는 문제들은 많은 경우 동적 계획법으로 해결할 수 있다.

#### <span class="custom-highlight">단순한 방법에서 시작할 수 있을까?</span>
비슷한 문제를 본 적이 없거나, 해당 해법을 적용할 수 없는 경우, 시간과 공간 제약을 일단 무시하고 "무식하게 풀 수 있을까?"라는 질문으로 시작해보자. 이 전략의 일차 목표는 간단하게 풀 수 있는 문제를 너무 복잡하게 생각해서 어렵게 푸는 경우를 예방한다. 컴퓨터는 사람보다 훨씬 빠르므로 오래걸릴 것 같은 코드도 시간 안에 수행할 수도 있다. 간단하고 느린 알고리즘으로 충분히 풀 수 있는 문제도 많다.  
물론 단순한 방법으로 모든 문제가 풀릴 리는 없다. 이 방법이 유용한 진짜 이유는 효율적인 알고리즘도 단순한 알고리즘을 기반으로 발전시킨 경우가 많기 때문이다. 

#### 내가 문제를 푸는 과정을 수식화할 수 있을까?
점진적인 접근 방법이 만능은 아니다. 처음에 생각한 것과 완전히 다른, 새로운 방향에서 접근해야 풀리는 문제들도 있다.  
새로운 아이디어가 필요한 문제를 풀 때 시도할 수 있는 방법 중 하나는 손으로 여러 간단한 입력을 직접 풀어보는 것이다. 자신이 문제를 해결하는 과정을 공식화해서 알고리즘을 만들 수 있는 경우도 많고, 그게 아니더라도 문제에서 고려해야할 부분을 추가로 알 수도 있다.  
손으로 문제를 풀어보는 습관은 문제를 어떻게 풀어야 할지 감이 온다고 하더라도 유용할 때가 많다. 프로그램을 작성하기 전에 알고리즘에서 간과한 점이 없는지 확인해볼 수 있기 때문이다. 

#### 문제를 단순화할 수 없을까?
주어진 문제의 좀더 쉬운 변형판을 먼저 풀어보는 것이 도움이 될 수 있다. 예를 들어 문제의 조건을 없애거나, 계산해야 하는 변수의 수를 줄이거나, 다차원의 문제를 1차원으로 줄여서 표현할 수도 있다. 

#### 그림으로 그려볼 수 있을까?
숫자의 나열보다 기하학적으로 표현했을 때 직관적으로 파악할 수 있는 경우가 많다.

#### 수식으로 표현할 수 있을까?
직관을 얻기 좋은 방향으로 사고를 전개하는 다른 접근 방식과는 반대로, 수식으로 문제를 표현하는 것이 도움이 되는 경우도 있다. 

#### 문제를 분해할 수 있을까?
대표적으로 제약 조건을 분해하여 단순한 형태를 갖는 조건의 집합으로 분해하는 방법이 있다. 한 개의 복잡한 조건보다 여러 개의 단순한 조건이 다루기 쉬운 경우가 많다.

#### 뒤에서부터 생각해서 문제를 풀 수 있을까?
내재된 순서를 바꿔서 효율화를 할 수 있는 경우도 있다. 예를 들어 사다리 게임의 당첨에서부터 밑에서 위로 한 번 올라가서 가장 좋은 시작 위치를 찾을 수 있다.

#### 순서를 강제할 수 있을까?
순서가 없는 문제에 순서를 강제해서 문제를 푸는 방법이있다. 좋은 예로 5x5 크기의 격자에서 모든 칸의 불을 켜는 문제가 있다. 격자의 한 칸을 클릭하면 그 칸과 상하좌우에 인접한 칸들의 상태가 동시에 변한다. 불이 켜져 있으면 꺼지고, 꺼져 있으면 켜진다. 클릭 수를 최소화해서 모든 칸에 있는 불을 켜는 것이 목표이다. 이 문제를 쉽게 풀기 위해서는 두 가지를 깨달아야 한다.
- 어떤 순서로 칸들을 클릭하든 상관이 없다. 각 칸의 상태는 자신과 인접한 칸들이 몇 번 클릭되었는지에 따라 정해지므로, 어떤 순서로 클릭을 하든 최종 격자 상태는 변함이 없다.
- 한 칸을 두 번 이상 클릭할 필요가 없다. 같은 칸을 두 번 클릭하는 것은 한 번도 클릭하지 않은 것과 같은 상태가 된다.

이 문제를 효율적으로 쉽게 푸는 방법은 항상 특정 순서대로 칸들을 눌러야 한다는 제약을 문제에 추가하는 것이다. 첫 번째 줄이 결정되고 나서 두 번째 줄 부터는 첫 번째 줄의 상태에 따라 클릭 여부가 자동으로 결정되게 된다. 

순서 강제 기법은 경우의 수를 셀 때도 유용한데, 한 가지 답을 두 가지 이상으로 만들 수 있을 때 답을 중복하여 세는 실수가 생길 수 있다. 이를 방지하기 위해 일들의 순서를 강제하는 것이 좋은 해결책이 될 수 있다.

#### 특정 형태의 답만을 고려할 수 있을까?
정규화 기법이란 우리가 고려해야 할 답들 중 결과 적으로 똑같은 것들을 그룹으로 묶은 뒤 각 그룹의 대표들만을 고려하는 방벙이다. 


## 03. 코딩과 디버깅에 관하여

### 3.1 도입: 코딩의 중요성을 간과하지 말라
프로그래밍 대회에서 좋은 성적을 올리기 위한 비결은 당장 빨리 코드를 작성하기보다 읽기 쉬운 코드를 작성하는 것이다. 

### 3.2 좋은 코드를 짜기 위한 원칙
일반적으로 실무에서 좋은 코드의 원칙이라고 할만한 것들 또한 대부분 프로그래밍 대회에도 적용된다. 프로그래밍 대회에서 특히 중요한 원칙과 예외들을 정리한다.

#### 간결한 코드 작성하기
대회에서는 코드 구조가 단순하고 각 변수를 읽고 쓰는 부분이 명확하기 때문에 전역 변수 활용을 많이 한다.

#### 적극적으로 코드 재사용하기
간결한 코드를 작성하기 위한 가장 직접적인 방법은 코드를 모듈화하는 것이다. 같은 코드가 세 번 이상 등작한다면 해당 코드를 함수로 분리해 재사용하자. 버그가 생겼을 때 간결한 코드 덕분에 디버깅 시간을 아낄 수 있다. (물론 실무에서 작성하듯 코드를 작성할 수는 없다.)

#### 표준 라이브러리 공부하기
처음 대회에 참가하는 학생들 중 기초적인 정렬, 자료 구조를 직접 작성하는 실수를 하곤 한다. 이는 시간 제한이 있는 프로그래밍 대회에서는 시간 낭비가 심하다. 기초적인 자료 구조와 알고리즘 사용법을 숙지하자.

#### 항상 같은 형태로 프로그램 작성하기
프로그래밍 대회에 참가하다 보면 여러 종류의 코드를 반복적으로 짜게 된다. 디버깅을 줄이기 위해서는 자주 작성하는 알고리즘이나 코드 등에 대해서는 한 번 검증된 코드를 작성하고 꾸준히 사용하는 것이 좋다. 이를 통해 도구가 아니라 문제에 집중할 수 있다.

#### 일관적이고 명료한 명명법 사용하기
프로그래밍 대회에 제출된 소스 코드들을 보면 이런 선언문들을 흔하게 볼 수 있다.
```cpp
int a[30][30], i, j, p[100], k=0, l=-1;
```
모호하지 않은 변수명과 함수명을 사용하는 버릇을 들이고, 사용하는 언어의 표준 라이브러리에서 사용하는 명명 규약을 익히는 것이 좋다. 

```cpp
// 점이 원 밖에 있을 때 True인지, 점이 원 안에 있을 때 True인지 모호하다
bool judge(int y, int x, int cy, int cx, int cr);

// 명료한 함수명으로 변경
bool isInsideCircle(int y, int x, int cy, int cx, int cr);
```

#### 모든 자료를 정규화해서 저장하기
동일한 자료를 두 가지 형태로 저장하지 않는 원칙이 있다. 예를 들어 유리수를 표현하는 클래스 `Fraction` 클래스를 작성한다고 하자. 이 때 유리수를 항상 약분해 기약 분수 형태로 정규화하여 표현하는 것이 좋다. 마찬가지로 -30도, 330도, 690도와 같이 동일한 각도를 표현하는 방법도 한 가지로 정의해두지 않으면 다루기가 어려워 지는 경우가 많다.

#### 코드와 데이터를 분리하기
날짜 출력 시 월을 숫자가 아니라 영어로 출력해야 한다고 하자. 프로그래밍을 처음 배운 사람들이 하는 큰 실수는 다음과 같은 열두 줄짜리 함수를 짜는 것이다.
```cpp
string getMonthName(int month) {
  if(month == 1) return "January";
  if(month == 2) return "February";
  ...
  return "December";
}
```
경험이 쌓이고 나면 이런 코드를 피하게 되는데, 코드의 논리와 상관 없는 데이터는 가능한 분리하는 것이 좋다.  
예를 들어 다음과 같은 테이블로 데이터를 만들 수 있다.
```cpp
const string monthName[] = { "January", "February", ..., "December" };
```

이 기법의 다른 좋은 예로 체스 같은 보드 게임이 있다. 체스판 상에서 말들의 움직임을 다루는 문제를 풀 경우 각 말이 움직일 수 있는 위치를 상대 좌표 배열로 저장해두면 좋다. 다음은 체스의 나이트가 움직일 수 있는 좌표를 배열로 선언하고 배열을 순회하면서 각 위치를 검사하는 것이 훨씬 간단하다.

```cpp
// Case 1. 하드코딩
nx = x + 2;
ny = y + 1;
doSomething(nx, ny);

nx = x + 2;
ny = y - 1;
doSomething(nx, ny);

...

// Case 2. 데이터 배열 사용
const int knightDx[8] = {2, 2, -2, -2, 1, 1, -1, -1};
const int knightDy[8] = {1, -1, 1, -1, 2, -2, 2, -2};

for (int i = 0; i < 8; i++) {
  nx = x + knightDx[i];
  ny = y + knightDy[i];
  doSomething(nx, ny);
}
```

### 3.3 자주하는 실수
#### 산술 오버플로
변수의 표현 범위를 벗어나는 값을 사용하는 경우

#### 배열 범위 밖 원소에 접근
배열 크기를 정할 때 신중히 계산을 하는 것이 필요하다. 에러가 발생하지 않으면서 의도치 않은 동작을 할 수도 있다.

#### 일관되지 않은 범위 표현 방식 사용

#### Off-by-one 오류
계산의 큰 줄기는 맞지만 하나가 모자라거나 많아 틀리는 코드 오류를 뜻한다. 예를 들어 A[1]부터 A[3]까지 평균을 구할 때 A[1]+A[2]+A[3]에 2가 아니라 3을 나눠주어야 한다.

#### 컴파일러가 잡아주지 못하는 상수 오타
문자열이나 숫자의 오타는 컴파일러가 잡아주지 못한다.

#### 스택 오버플로
재귀 호출의 깊이가 너무 깊어지면 스택 오버플로가 발생할 수 있다. 특히 크기가 큰 지역 변수를 스택에 잡으면 금방 오버플로가 발생할 수 있다.

#### 다차원 배열 인덱스 순서 바꿔 쓰기

#### 잘못된 비교 함수 작성

#### 최소, 최대 예외 잘못 다루기
예를 들어 소수 판별 시 1을 소수로 판정하거나, 모든 짝수를 소수가 아니라고 판정하여 2에 대해 오답 발생.

#### 연산자 수선순위 잘못 쓰기

```cpp
if(b & 1 == 0)
// 위 코드의 계산 순서는 
if(b & (1 == 0))
```

#### 너무 느린 입출력 방식 선택

#### 변수 초기화 문제
한 번의 실행에서 여러 개 테스트 케이스 입력에 대해 답을 처리하는 경우가 많다.
이전 테스트 케이스에서 사용한 전역 변수 값을 실수로 초기화하지 않는 경우 잘못된 결과가 나올 수 있다. 

### 3.4 디버깅과 테스팅

#### 디버깅에 관하여
대회에서 디버거의 유용성에 한계가 있다.
- 소스 코드가 길지 않지 때문에 소스 코드를 읽고 검증하는 것이 가능하다.
- 재귀 호출이나 중복 반복문을 많이 사용하는 복잡한 코드는 디버거 디버깅이 어렵다.
대신에 다음과 같은 방법을 이용할 수 있다.
- 작은 입력에 대해 테스트하기
- assert 이용하기
- 중간 결과 출력하기

### 3.5 변수 범위의 이해
생략

### 3.6 실수 자료형의 이해
생략
